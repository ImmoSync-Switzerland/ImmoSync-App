platform :ios, '15.0'

# Explicitly load installer types to avoid CocoaPods 1.16+ NameError on Ruby 3.3 runners
require 'cocoapods/installer/installation_options'

# CocoaPods analytics sends network stats synchronously affecting flutter build latency.
ENV['COCOAPODS_DISABLE_STATS'] = 'true'
# Some pods (e.g., Stripe) can fail when shallow-cloned on CI runners; force full clones to avoid tag lookup errors.
ENV['COCOAPODS_DISABLE_GIT_DEPTH'] = 'true'
require 'shellwords'

project 'Runner', {
  'Debug' => :debug,
  'Profile' => :release,
  'Release' => :release,
}

def flutter_root
  generated_xcode_build_settings_path = File.expand_path(File.join('..', 'Flutter', 'Generated.xcconfig'), __FILE__)
  unless File.exist?(generated_xcode_build_settings_path)
    raise "#{generated_xcode_build_settings_path} must exist. If you're running pod install manually, run:\n  flutter pub get\n  flutter precache --ios\n"
  end

  File.foreach(generated_xcode_build_settings_path) do |line|
    matches = line.match(/FLUTTER_ROOT\=(.*)/)
    return matches[1].strip if matches
  end
  raise "FLUTTER_ROOT not found in #{generated_xcode_build_settings_path}. Try deleting Flutter/Generated.xcconfig and run flutter pub get."
end

require File.expand_path(File.join('packages', 'flutter_tools', 'bin', 'podhelper'), flutter_root)

flutter_ios_podfile_setup

target 'Runner' do
  # FlutterFire recommends static frameworks to avoid Swift module import issues (e.g. GoogleUtilities_AppDelegateSwizzler).
  $FirebaseAsStaticFramework = true
  use_frameworks! :linkage => :static
  use_modular_headers!

  # Ensure GoogleUtilities is built with a module and all required swizzler bits.
  pod 'GoogleUtilities', '8.1.0', :subspecs => [
    'AppDelegateSwizzler',
    'MethodSwizzler',
    'Environment',
    'Network',
    'NSData+zlib',
    'Logger',
    'UserDefaults'
  ]

  flutter_install_all_ios_pods File.dirname(File.realpath(__FILE__))
end

post_install do |installer|
  # CocoaPods 1.16+ drops installer.platform_name; provide a safe shim to keep older hooks working.
  installer.define_singleton_method(:platform_name) do
    pods_project.targets.map { |t| t.respond_to?(:platform_name) ? t.platform_name : nil }.compact.first || :ios
  end unless installer.respond_to?(:platform_name)

  # CocoaPods 1.16+ also removes installer.deployment_target; provide a shim for Flutter's podhelper.
  installer.define_singleton_method(:deployment_target) do
    # Prefer the Podfile platform if available, else fall back to 15.0 (our declared platform)
    platform = installer.podfile.target_definition_list.map(&:platform).compact.first
    if platform.respond_to?(:deployment_target)
      platform.deployment_target.to_s
    else
      '15.0'
    end
  end unless installer.respond_to?(:deployment_target)

  installer.pods_project.targets.each do |target|
    target.build_configurations.each do |config|
      config.build_settings['IPHONEOS_DEPLOYMENT_TARGET'] = '15.0'
      flags = Array(config.build_settings['OTHER_SWIFT_FLAGS']).dup
      flags << '-enable-experimental-feature' << 'AccessLevelOnImport'
      config.build_settings['OTHER_SWIFT_FLAGS'] = flags

      # FirebaseAuth imports GoogleUtilities_AppDelegateSwizzler; ensure GoogleUtilities targets define a module.
      if target.name.include?('GoogleUtilities')
        config.build_settings['DEFINES_MODULE'] = 'YES'
        config.build_settings['CLANG_ENABLE_MODULES'] = 'YES'
      end
    end
    flutter_additional_ios_build_settings(target)
  end

  # Ensure dedicated modulemaps exist for GoogleUtilities subspecs Firebase imports with underscore modules.
  gu_subspecs = {
    'AppDelegateSwizzler' => 'GULAppDelegateSwizzler.h',
    'Environment' => 'GULEnvironment.h',
    'MethodSwizzler' => 'GULSwizzler.h',
    'Logger' => 'GULLogger.h',
    'Network' => 'GULNetwork.h',
    'NSData+zlib' => 'GULNSData+zlib.h',
    'UserDefaults' => 'GULUserDefaults.h'
  }

  gu_subspecs.each do |subspec, header_name|
    header_path = Dir.glob(File.join(installer.sandbox.root, 'GoogleUtilities', '**', header_name)).first
    next unless header_path && File.exist?(header_path)

    ts_dir = File.join(installer.sandbox.root, 'Target Support Files', "GoogleUtilities-#{subspec}")
    FileUtils.mkdir_p(ts_dir)
    modulemap = File.join(ts_dir, "GoogleUtilities-#{subspec}.modulemap")
    File.write(modulemap, <<~MAP)
module GoogleUtilities_#{subspec} {
  header "#{header_path}"
  export *
}
MAP

    installer.pods_project.targets.each do |target|
      next unless target.name == "GoogleUtilities-#{subspec}" || target.name == "GoogleUtilities_#{subspec}"
      target.build_configurations.each do |config|
        config.build_settings['MODULEMAP_FILE'] = modulemap
        config.build_settings['DEFINES_MODULE'] = 'YES'
        config.build_settings['CLANG_ENABLE_MODULES'] = 'YES'
      end
    end

  end

  # Build a canonical modulemap + umbrella header for all GoogleUtilities subspecs so Swift imports
  # never depend on CocoaPods' generated files (which can be skipped when we override modulemaps).
  gu_ts_dir = File.join(installer.sandbox.root, 'Target Support Files', 'GoogleUtilities')
  gu_modulemap = File.join(gu_ts_dir, 'GoogleUtilities.modulemap')
  FileUtils.mkdir_p(gu_ts_dir)

  header_paths = {}
  gu_subspecs.each do |subspec, header_name|
    header_path = Dir.glob(File.join(installer.sandbox.root, 'GoogleUtilities', '**', header_name)).first
    header_paths[subspec] = header_path if header_path && File.exist?(header_path)
  end

  gu_umbrella_path = File.join(gu_ts_dir, 'GoogleUtilities-umbrella.h')
  File.open(gu_umbrella_path, 'w') do |f|
    f.puts '#ifdef __OBJC__'
    header_paths.values.compact.uniq.each { |hdr| f.puts "#import \"#{hdr}\"" }
    f.puts '#endif'
  end

  modulemap_contents = <<~MAP
module GoogleUtilities {
  umbrella header "#{gu_umbrella_path}"
  export *
  module * { export * }
}
MAP

  header_paths.each do |subspec, hdr|
    modulemap_contents << "\nmodule GoogleUtilities_#{subspec} {\n  header \"#{hdr}\"\n  export *\n}\n"
  end

  File.write(gu_modulemap, modulemap_contents)

  installer.pods_project.targets.each do |target|
    next unless target.name.include?('GoogleUtilities')
    target.build_configurations.each do |config|
      config.build_settings['MODULEMAP_FILE'] = gu_modulemap
      config.build_settings['DEFINES_MODULE'] = 'YES'
      config.build_settings['CLANG_ENABLE_MODULES'] = 'YES'
      flags = Array(config.build_settings['OTHER_SWIFT_FLAGS']).dup
      flag = "-fmodule-map-file=#{Shellwords.escape(gu_modulemap)}"
      flags += ['-Xcc', flag] unless flags.include?(flag) || (flags.include?('-Xcc') && flags.include?(flag))
      config.build_settings['OTHER_SWIFT_FLAGS'] = flags
    end
  end

  # Propagate the consolidated modulemap to downstream Swift consumers (e.g., FirebaseAuth) so
  # imports like GoogleUtilities_Environment resolve even when the GoogleUtilities targets are
  # built as static frameworks.
  installer.pods_project.targets.each do |target|
    next unless target.name.start_with?('Pods-') || target.name.start_with?('Firebase') || target.name.start_with?('GoogleUtilities')

    target.build_configurations.each do |config|
      flags = Array(config.build_settings['OTHER_SWIFT_FLAGS']).dup
      flag = "-fmodule-map-file=#{Shellwords.escape(gu_modulemap)}"
      # Add as an Xcc flag to ensure the Swift frontend forwards it to Clang.
      unless flags.include?(flag) || (flags.include?('-Xcc') && flags.include?(flag))
        flags += ['-Xcc', flag]
      end
      config.build_settings['OTHER_SWIFT_FLAGS'] = flags
    end
  end

  gu_umbrella = File.join(installer.sandbox.root, 'Target Support Files', 'GoogleUtilities', 'GoogleUtilities-umbrella.h')
  if File.exist?(gu_umbrella)
    filtered = File.read(gu_umbrella).lines.reject do |line|
      line.include?('GULAppDelegateSwizzler.h') || line.include?('GULSceneDelegateSwizzler.h')
    end
    File.write(gu_umbrella, filtered.join)
  end

  installer.pods_project.targets.each do |target|
    next unless target.name.include?('GoogleUtilities')
    target.build_configurations.each do |config|
      config.build_settings['DEFINES_MODULE'] = 'YES'
      config.build_settings['CLANG_ENABLE_MODULES'] = 'YES'
    end
  end

  # Ensure a dedicated modulemap exists for GoogleUtilities_AppDelegateSwizzler and avoid module cycles.
  swizzler_header = Dir.glob(File.join(installer.sandbox.root, 'GoogleUtilities', '**', 'GULAppDelegateSwizzler.h')).first
  if swizzler_header && File.exist?(swizzler_header)
    ts_dir = File.join(installer.sandbox.root, 'Target Support Files', 'GoogleUtilities-AppDelegateSwizzler')
    FileUtils.mkdir_p(ts_dir)
    swizzler_modulemap = File.join(ts_dir, 'GoogleUtilities-AppDelegateSwizzler.modulemap')
    File.write(swizzler_modulemap, <<~MAP)
module GoogleUtilities_AppDelegateSwizzler {
  header "#{swizzler_header}"
  export *
}
MAP

    installer.pods_project.targets.each do |target|
      next unless target.name == 'GoogleUtilities-AppDelegateSwizzler'
      target.build_configurations.each do |config|
        config.build_settings['MODULEMAP_FILE'] = swizzler_modulemap
        config.build_settings['DEFINES_MODULE'] = 'YES'
        config.build_settings['CLANG_ENABLE_MODULES'] = 'YES'
      end
    end

    gu_umbrella = File.join(installer.sandbox.root, 'Target Support Files', 'GoogleUtilities', 'GoogleUtilities-umbrella.h')
    if File.exist?(gu_umbrella)
      filtered = File.read(gu_umbrella).lines.reject { |l| l.include?('GULAppDelegateSwizzler.h') || l.include?('GULSceneDelegateSwizzler.h') }
      File.write(gu_umbrella, filtered.join)
    end

  end

  # Patch Firebase pods to strip Swift 6-only syntax that Xcode 15.4 cannot compile.
  patches = [
    { file: 'FirebaseDataEncoder.swift', from: '-> sending Any', to: '-> Any' },
    { file: 'UnfairLock.swift', from: /\bsending\s+/, to: '' },
    { file: 'HeartbeatsPayload.swift', from: /^(internal|package)\s+import/, to: 'import' },
    { file: 'UnfairLock.swift', from: /^(private|package)\s+import/, to: 'import' }
  ]

  patches.each do |patch|
    Dir.glob(File.join(installer.sandbox.root, '**', patch[:file])).each do |path|
      contents = File.read(path)
      fixed = contents.gsub(patch[:from], patch[:to])
      File.write(path, fixed) if fixed != contents
    end
  end
end
