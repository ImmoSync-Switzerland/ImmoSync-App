name: iOS IPA CI

on:
  push:
    paths-ignore:
      - 'public/downloads/**'
  workflow_dispatch:

jobs:
  cleanup-artifacts:
    name: Cleanup Old Artifacts
    runs-on: ubuntu-latest
    permissions:
      actions: write
      contents: read
    steps:
      - uses: actions/checkout@v4

      - name: Delete old artifacts
        uses: jimschubert/delete-artifacts-action@v1
        with:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          log_level: 'error'
          min_bytes: '0'
        continue-on-error: true

  build-ipa:
    name: Build Release IPA
    runs-on: macos-14
    timeout-minutes: 60
    needs: cleanup-artifacts
    if: always()
    outputs:
      app_version: ${{ steps.extract_version.outputs.app_version }}

    permissions:
      contents: write
      actions: read
      checks: read
      security-events: read

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Flutter
        id: flutter-setup
        uses: subosito/flutter-action@v2
        with:
          flutter-version: '3.35.5'
          cache: true

      - name: Verify Flutter installation
        run: |
          echo "::group::Environment"
          echo "PATH=$PATH"
          echo "Home listing:"; ls -1 $HOME | head -n 50 || true
          echo "Toolcache flutter dirs:"; ls -d $HOME/hostedtoolcache/flutter* 2>/dev/null || echo 'No flutter toolcache dirs'
          echo "::endgroup::"
          if ! command -v flutter >/dev/null 2>&1; then
            echo 'Flutter not found after setup step' >&2
            exit 1
          fi
          flutter --version
          flutter doctor -v | sed -e 's/\x1b\[[0-9;]*m//g'

      - name: Flutter doctor (redundant safety)
        run: flutter doctor -v

      - name: Restore pub dependencies
        working-directory: immolink
        run: flutter pub get

      - name: Extract app version
        id: extract_version
        run: |
          VERSION_LINE=$(grep '^version:' immolink/pubspec.yaml)
          VERSION=$(echo "$VERSION_LINE" | cut -d ' ' -f2 | tr -d '\r')
          if [ -z "$VERSION" ]; then
            echo 'Unable to determine app version from pubspec.yaml' >&2
            exit 1
          fi
          echo "Detected version: $VERSION"
          echo "app_version=$VERSION" >> $GITHUB_OUTPUT

      - name: Run analyzer (warnings only)
        working-directory: immolink
        run: |
          flutter analyze || true

      - name: Check iOS CI prerequisites
        id: prereqs
        env:
          API_URL: ${{ secrets.CLIENT_API_URL }}
          STRIPE_PUBLISHABLE_KEY: ${{ secrets.STRIPE_PUBLISHABLE_KEY }}
          GOOGLE_CLIENT_ID: ${{ secrets.GOOGLE_CLIENT_ID }}
          GOOGLE_SERVICE_INFO_PLIST: ${{ secrets.GOOGLE_SERVICE_INFO_PLIST }}
          GOOGLE_SERVICE_INFO_PLIST_B64: ${{ secrets.GOOGLE_SERVICE_INFO_PLIST_B64 }}
          IOS_CERT_P12_B64: ${{ secrets.IOS_CERT_P12_B64 }}
          IOS_CERT_PASSWORD: ${{ secrets.IOS_CERT_PASSWORD }}
          IOS_PROVISIONING_PROFILE_B64: ${{ secrets.IOS_PROVISIONING_PROFILE_B64 }}
          IOS_DEVELOPMENT_TEAM: ${{ secrets.IOS_DEVELOPMENT_TEAM }}
          IOS_BUNDLE_IDENTIFIER: ${{ secrets.IOS_BUNDLE_IDENTIFIER }}
        run: |
          set -euo pipefail
          ON_MAIN="false"
          if [ "${GITHUB_REF:-}" = "refs/heads/main" ]; then
            ON_MAIN="true"
          fi

          missing=()
          for var in API_URL STRIPE_PUBLISHABLE_KEY GOOGLE_CLIENT_ID IOS_DEVELOPMENT_TEAM IOS_BUNDLE_IDENTIFIER; do
            if [ -z "${!var:-}" ]; then
              missing+=("$var")
            fi
          done

          if [ -z "${GOOGLE_SERVICE_INFO_PLIST:-}" ] && [ -z "${GOOGLE_SERVICE_INFO_PLIST_B64:-}" ]; then
            missing+=("GOOGLE_SERVICE_INFO_PLIST(_B64)")
          fi

          for var in IOS_CERT_P12_B64 IOS_CERT_PASSWORD IOS_PROVISIONING_PROFILE_B64; do
            if [ -z "${!var:-}" ]; then
              missing+=("$var")
            fi
          done

          if [ ${#missing[@]} -gt 0 ]; then
            msg="Missing required iOS secrets: ${missing[*]}"
            echo "$msg" >&2
            {
              echo "ready=false"
              echo "reason=$msg"
            } >> "$GITHUB_OUTPUT"
            echo "### iOS Build Skipped" >> "$GITHUB_STEP_SUMMARY"
            echo "$msg" >> "$GITHUB_STEP_SUMMARY"
            if [ "$ON_MAIN" = "true" ]; then
              exit 1
            fi
            exit 0
          fi

          echo "ready=true" >> "$GITHUB_OUTPUT"

      - name: Validate iOS secrets (no values printed)
        if: steps.prereqs.outputs.ready == 'true'
        env:
          API_URL: ${{ secrets.CLIENT_API_URL }}
          STRIPE_PUBLISHABLE_KEY: ${{ secrets.STRIPE_PUBLISHABLE_KEY }}
          GOOGLE_CLIENT_ID: ${{ secrets.GOOGLE_CLIENT_ID }}
          GOOGLE_SERVICE_INFO_PLIST: ${{ secrets.GOOGLE_SERVICE_INFO_PLIST }}
          GOOGLE_SERVICE_INFO_PLIST_B64: ${{ secrets.GOOGLE_SERVICE_INFO_PLIST_B64 }}
          IOS_CERT_P12_B64: ${{ secrets.IOS_CERT_P12_B64 }}
          IOS_CERT_PASSWORD: ${{ secrets.IOS_CERT_PASSWORD }}
          IOS_PROVISIONING_PROFILE_B64: ${{ secrets.IOS_PROVISIONING_PROFILE_B64 }}
          IOS_DEVELOPMENT_TEAM: ${{ secrets.IOS_DEVELOPMENT_TEAM }}
          IOS_BUNDLE_IDENTIFIER: ${{ secrets.IOS_BUNDLE_IDENTIFIER }}
        run: |
          set -euo pipefail

          status_ok() { echo "[ok] $1"; }
          status_fail() { echo "[fail] $1"; exit 1; }

          # Basic presence checks (already gated, but double-check without printing values)
          for var in API_URL STRIPE_PUBLISHABLE_KEY GOOGLE_CLIENT_ID IOS_DEVELOPMENT_TEAM IOS_BUNDLE_IDENTIFIER; do
            if [ -z "${!var:-}" ]; then
              status_fail "$var is empty"
            fi
          done

          # GoogleService-Info.plist validation (raw or base64)
          gs_tmp=$(mktemp)
          if [ -n "${GOOGLE_SERVICE_INFO_PLIST_B64:-}" ]; then
            printf '%s' "$GOOGLE_SERVICE_INFO_PLIST_B64" | tr -d '\r\n' | base64 --decode > "$gs_tmp" 2>/dev/null || \
              printf '%s' "$GOOGLE_SERVICE_INFO_PLIST_B64" | tr -d '\r\n' | base64 -d > "$gs_tmp"
          elif [ -n "${GOOGLE_SERVICE_INFO_PLIST:-}" ]; then
            printf '%s' "$GOOGLE_SERVICE_INFO_PLIST" > "$gs_tmp"
          else
            status_fail "GoogleService-Info.plist secret missing"
          fi
          if ! plutil -lint "$gs_tmp" >/dev/null 2>&1; then
            status_fail "GoogleService-Info.plist failed plutil lint"
          fi
          rm -f "$gs_tmp"
          status_ok "GoogleService-Info.plist present and valid plist"

          # P12 decode + password check
          p12_tmp=$(mktemp)
          printf '%s' "$IOS_CERT_P12_B64" | tr -d '\r\n' | base64 --decode > "$p12_tmp" 2>/dev/null || \
            printf '%s' "$IOS_CERT_P12_B64" | tr -d '\r\n' | base64 -d > "$p12_tmp"
          if ! openssl pkcs12 -in "$p12_tmp" -passin pass:"$IOS_CERT_PASSWORD" -info -nokeys >/dev/null 2>&1; then
            status_fail "PKCS12 failed to open with provided password"
          fi
          rm -f "$p12_tmp"
          status_ok "PKCS12 decodes and password accepted"

          # Provisioning profile decode + plist parse
          profile_tmp=$(mktemp)
          printf '%s' "$IOS_PROVISIONING_PROFILE_B64" | tr -d '\r\n' | base64 --decode > "$profile_tmp" 2>/dev/null || \
            printf '%s' "$IOS_PROVISIONING_PROFILE_B64" | tr -d '\r\n' | base64 -d > "$profile_tmp"
          if ! security cms -D -i "$profile_tmp" >/dev/null 2>&1; then
            status_fail "Provisioning profile failed CMS decode"
          fi
          status_ok "Provisioning profile decodes"
          rm -f "$profile_tmp"

          {
            echo "## iOS secret validation"
            echo "- API_URL / STRIPE_PUBLISHABLE_KEY / GOOGLE_CLIENT_ID: present"
            echo "- GOOGLE_SERVICE_INFO_PLIST(_B64): valid plist"
            echo "- IOS_CERT_P12_B64: decodes with password"
            echo "- IOS_PROVISIONING_PROFILE_B64: CMS decode ok"
            echo "- IOS_DEVELOPMENT_TEAM / IOS_BUNDLE_IDENTIFIER: present"
          } >> "$GITHUB_STEP_SUMMARY"

      - name: Create .env file from secrets
        if: steps.prereqs.outputs.ready == 'true'
        working-directory: immolink
        env:
          API_URL: ${{ secrets.CLIENT_API_URL }}
          STRIPE_PUBLISHABLE_KEY: ${{ secrets.STRIPE_PUBLISHABLE_KEY }}
          GOOGLE_CLIENT_ID: ${{ secrets.GOOGLE_CLIENT_ID }}
          MONGODB_URI: ${{ secrets.MONGODB_URI }}
          MONGODB_DB_NAME: ${{ secrets.MONGODB_DB_NAME }}
          WS_URL: ${{ secrets.WS_URL }}
        run: |
          echo "Creating .env file for flutter_dotenv..."
          cat > .env << EOF
          API_URL=${API_URL}
          STRIPE_PUBLISHABLE_KEY=${STRIPE_PUBLISHABLE_KEY}
          GOOGLE_CLIENT_ID=${GOOGLE_CLIENT_ID}
          MONGODB_URI=${MONGODB_URI:-}
          MONGODB_DB_NAME=${MONGODB_DB_NAME:-}
          WS_URL=${WS_URL:-}
          EOF
          echo ".env file created with $(wc -l < .env) lines"

      - name: Create GoogleService-Info.plist from secret
        if: steps.prereqs.outputs.ready == 'true'
        working-directory: immolink/ios/Runner
        env:
          GOOGLE_SERVICE_INFO_PLIST: ${{ secrets.GOOGLE_SERVICE_INFO_PLIST }}
          GOOGLE_SERVICE_INFO_PLIST_B64: ${{ secrets.GOOGLE_SERVICE_INFO_PLIST_B64 }}
        run: |
          RAW_SECRET="$GOOGLE_SERVICE_INFO_PLIST"
          B64_SECRET="$GOOGLE_SERVICE_INFO_PLIST_B64"
          if [ -n "$B64_SECRET" ]; then
            echo 'Using base64-encoded GoogleService-Info.plist secret'
            printf '%s' "$B64_SECRET" | tr -d '\r\n' | base64 --decode > GoogleService-Info.plist 2>/dev/null || \
              printf '%s' "$B64_SECRET" | tr -d '\r\n' | base64 -d > GoogleService-Info.plist
          elif [ -n "$RAW_SECRET" ]; then
            echo 'Using raw GoogleService-Info.plist secret'
            printf '%s' "$RAW_SECRET" > GoogleService-Info.plist
          else
            echo 'Missing required secret: provide either GOOGLE_SERVICE_INFO_PLIST (raw plist) or GOOGLE_SERVICE_INFO_PLIST_B64 (base64)' >&2
            exit 1
          fi
          plutil -lint GoogleService-Info.plist

      - name: Install CocoaPods dependencies (clean)
        if: steps.prereqs.outputs.ready == 'true'
        working-directory: immolink/ios
        run: |
          set -euo pipefail
          rm -rf Pods Podfile.lock
          pod --version
          pod install --repo-update

      - name: Verify GoogleUtilities AppDelegateSwizzler module
        if: steps.prereqs.outputs.ready == 'true'
        working-directory: immolink/ios
        run: |
          set -euo pipefail
          # CocoaPods target support file names often use '-' even when the Swift module uses '_'.
          # Verify by modulemap content and fall back to filename-based heuristics.
          if grep -R --line-number --fixed-strings "module GoogleUtilities_AppDelegateSwizzler" "Pods/Target Support Files" "Pods" >/dev/null 2>&1; then
            echo "Found module declaration for GoogleUtilities_AppDelegateSwizzler"
            exit 0
          fi

          candidates="$(find Pods -type f -iname '*appdelegateswizzler*.modulemap' -print || true)"
          if [ -n "${candidates:-}" ]; then
            echo "Found AppDelegateSwizzler modulemap candidate(s):"
            echo "$candidates"
            echo "Contents preview (first match):"
            first="$(echo "$candidates" | head -n1)"
            sed -n '1,80p' "$first" || true
            exit 0
          fi

          echo "Missing GoogleUtilities AppDelegateSwizzler modulemap after pod install" >&2
          echo "AppDelegateSwizzler-related files found under Pods/:" >&2
          find Pods -maxdepth 6 -iname '*appdelegateswizzler*' -print || true
          echo "Pods/Target Support Files listing (top-level):" >&2
          find "Pods/Target Support Files" -maxdepth 2 -type f -name "*.modulemap" -print | head -n 50 || true
          exit 1

      - name: Prepare signing assets
        id: signing
        if: steps.prereqs.outputs.ready == 'true'
        env:
          IOS_CERT_P12_B64: ${{ secrets.IOS_CERT_P12_B64 }}
          IOS_CERT_PASSWORD: ${{ secrets.IOS_CERT_PASSWORD }}
          IOS_PROVISIONING_PROFILE_B64: ${{ secrets.IOS_PROVISIONING_PROFILE_B64 }}
          IOS_DEVELOPMENT_TEAM: ${{ secrets.IOS_DEVELOPMENT_TEAM }}
          IOS_BUNDLE_IDENTIFIER: ${{ secrets.IOS_BUNDLE_IDENTIFIER }}
        run: |
          set -euo pipefail
          if [ -z "$IOS_CERT_P12_B64" ] || [ -z "$IOS_CERT_PASSWORD" ] || [ -z "$IOS_PROVISIONING_PROFILE_B64" ]; then
            echo 'Missing required signing secrets: IOS_CERT_P12_B64, IOS_CERT_PASSWORD, IOS_PROVISIONING_PROFILE_B64' >&2
            echo "ready=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          decode_b64() {
            # Accept base64 with or without newlines/CRLF; avoid echo quirks with leading '-' sequences.
            local input="$1"
            local output="$2"
            printf '%s' "$input" | tr -d '\r\n' | base64 --decode > "$output" 2>/dev/null || \
              printf '%s' "$input" | tr -d '\r\n' | base64 -d > "$output"
          }

          CERT_PASSWORD="$(printf '%s' "$IOS_CERT_PASSWORD" | tr -d '\r\n')"

          KEYCHAIN_PASSWORD=$(openssl rand -base64 32)
          KEYCHAIN_PATH=$HOME/Library/Keychains/build.keychain-db
          security create-keychain -p "$KEYCHAIN_PASSWORD" build.keychain
          security set-keychain-settings -lut 21600 build.keychain
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" build.keychain
          security list-keychains -d user -s build.keychain $(security list-keychains -d user | tr -d '"')
          security default-keychain -d user -s build.keychain

          decode_b64 "$IOS_CERT_P12_B64" signing_cert.p12
          if ! openssl pkcs12 -in signing_cert.p12 -passin pass:"$CERT_PASSWORD" -info -nokeys >/dev/null 2>&1; then
            echo 'PKCS12 validation failed: check IOS_CERT_P12_B64 is the full base64 of a .p12 and IOS_CERT_PASSWORD matches the .p12 password.' >&2
            exit 1
          fi
          if ! security import signing_cert.p12 -f pkcs12 -k build.keychain -P "$CERT_PASSWORD" -T /usr/bin/codesign -T /usr/bin/security; then
            echo 'Initial PKCS12 import failed; attempting to re-pack .p12 into legacy format for macOS Keychain import...' >&2
            echo "OpenSSL: $(openssl version)" >&2

            repack_err="$(mktemp)"
            repack_pem="$(mktemp)"
            # Re-pack using older algorithms that Keychain commonly accepts (works even when OpenSSL lacks `-legacy`).
            if ! openssl pkcs12 -in signing_cert.p12 -passin pass:"$CERT_PASSWORD" -nodes -out "$repack_pem" >/dev/null 2>"$repack_err"; then
              echo 'Failed to unpack PKCS12 for repack; OpenSSL output:' >&2
              sed -n '1,60p' "$repack_err" >&2 || true
              rm -f "$repack_err" "$repack_pem"
              exit 1
            fi
            if ! openssl pkcs12 -export -in "$repack_pem" -out signing_cert_legacy.p12 -passout pass:"$CERT_PASSWORD" -certpbe PBE-SHA1-3DES -keypbe PBE-SHA1-3DES -macalg sha1 >/dev/null 2>"$repack_err"; then
              echo 'Failed to re-pack PKCS12 into legacy algorithms; OpenSSL output:' >&2
              sed -n '1,60p' "$repack_err" >&2 || true
              rm -f "$repack_err" "$repack_pem"
              exit 1
            fi
            rm -f "$repack_err" "$repack_pem"
            if [ ! -s signing_cert_legacy.p12 ]; then
              echo 'Failed to generate legacy PKCS12; re-export the .p12 from Keychain Access (must include the private key) and re-upload secrets.' >&2
              exit 1
            fi
            security import signing_cert_legacy.p12 -f pkcs12 -k build.keychain -P "$CERT_PASSWORD" -T /usr/bin/codesign -T /usr/bin/security
            rm -f signing_cert_legacy.p12
          fi
          rm -f signing_cert.p12
          security set-key-partition-list -S apple-tool:,apple: -s -k "$KEYCHAIN_PASSWORD" build.keychain

          PROFILE_DIR="$HOME/Library/MobileDevice/Provisioning Profiles"
          mkdir -p "$PROFILE_DIR"
          PROFILE_PATH="$PROFILE_DIR/Immolink.mobileprovision"
          decode_b64 "$IOS_PROVISIONING_PROFILE_B64" "$PROFILE_PATH"

          PROFILE_PLIST=$(mktemp)
          security cms -D -i "$PROFILE_PATH" > "$PROFILE_PLIST"
          PROFILE_NAME=$(/usr/libexec/PlistBuddy -c "Print :Name" "$PROFILE_PLIST")
          PROFILE_UUID=$(/usr/libexec/PlistBuddy -c "Print :UUID" "$PROFILE_PLIST")
          PROFILE_APP_ID=$(/usr/libexec/PlistBuddy -c "Print :Entitlements:application-identifier" "$PROFILE_PLIST" 2>/dev/null || true)
          PROFILE_GET_TASK_ALLOW=$(/usr/libexec/PlistBuddy -c "Print :Entitlements:get-task-allow" "$PROFILE_PLIST" 2>/dev/null || true)
          PROFILE_HAS_DEVICES=$(/usr/libexec/PlistBuddy -c "Print :ProvisionedDevices" "$PROFILE_PLIST" 2>/dev/null >/dev/null && echo "true" || echo "false")
          PROFILE_PROVISIONS_ALL_DEVICES=$(/usr/libexec/PlistBuddy -c "Print :ProvisionsAllDevices" "$PROFILE_PLIST" 2>/dev/null || true)
          rm -f "$PROFILE_PLIST"

          if [ -z "$PROFILE_NAME" ] || [ -z "$PROFILE_UUID" ] || [ -z "$PROFILE_APP_ID" ]; then
            echo 'Unable to read provisioning profile metadata (Name/UUID/Application Identifier)' >&2
            exit 1
          fi

          PROFILE_TEAM_ID="${PROFILE_APP_ID%%.*}"
          if [ "$PROFILE_TEAM_ID" = "$PROFILE_APP_ID" ]; then
            PROFILE_TEAM_ID=""
          fi
          PROFILE_BUNDLE_ID="${PROFILE_APP_ID#*.}"
          if [ "$PROFILE_BUNDLE_ID" = "$PROFILE_APP_ID" ]; then
            PROFILE_BUNDLE_ID="$PROFILE_APP_ID"
          fi

          if [ -n "${IOS_DEVELOPMENT_TEAM:-}" ] && [ -n "$PROFILE_TEAM_ID" ] && [ "$IOS_DEVELOPMENT_TEAM" != "$PROFILE_TEAM_ID" ]; then
            echo "Provisioning profile team ID ($PROFILE_TEAM_ID) does not match IOS_DEVELOPMENT_TEAM ($IOS_DEVELOPMENT_TEAM)" >&2
            exit 1
          fi

          if [ -n "${IOS_BUNDLE_IDENTIFIER:-}" ] && [ "$IOS_BUNDLE_IDENTIFIER" != "$PROFILE_BUNDLE_ID" ]; then
            echo "Provisioning profile bundle identifier ($PROFILE_BUNDLE_ID) does not match IOS_BUNDLE_IDENTIFIER ($IOS_BUNDLE_IDENTIFIER)" >&2
            exit 1
          fi

          TEAM_ID="${IOS_DEVELOPMENT_TEAM:-$PROFILE_TEAM_ID}"
          if [ -z "$TEAM_ID" ]; then
            echo 'Unable to determine Apple development team ID from secrets or profile' >&2
            exit 1
          fi

          # Derive an export method suggestion based on profile type unless explicitly provided later.
          # - development: get-task-allow == true
          # - enterprise: ProvisionsAllDevices == true
          # - ad-hoc: has ProvisionedDevices array
          # - app-store: default
          EXPORT_METHOD_FROM_PROFILE="app-store"
          if [ "${PROFILE_GET_TASK_ALLOW:-}" = "true" ]; then
            EXPORT_METHOD_FROM_PROFILE="development"
          elif [ "${PROFILE_PROVISIONS_ALL_DEVICES:-}" = "true" ]; then
            EXPORT_METHOD_FROM_PROFILE="enterprise"
          elif [ "${PROFILE_HAS_DEVICES:-}" = "true" ]; then
            EXPORT_METHOD_FROM_PROFILE="ad-hoc"
          fi

          echo "ready=true" >> $GITHUB_OUTPUT
          echo "::add-mask::$KEYCHAIN_PASSWORD"
          echo "keychain_password=$KEYCHAIN_PASSWORD" >> $GITHUB_OUTPUT
          echo "keychain_path=$KEYCHAIN_PATH" >> $GITHUB_OUTPUT
          echo "::add-mask::$PROFILE_UUID"
          echo "::add-mask::$TEAM_ID"
          echo "profile_name=$PROFILE_NAME" >> $GITHUB_OUTPUT
          echo "profile_uuid=$PROFILE_UUID" >> $GITHUB_OUTPUT
          echo "bundle_id=$PROFILE_BUNDLE_ID" >> $GITHUB_OUTPUT
          echo "team_id=$TEAM_ID" >> $GITHUB_OUTPUT
          echo "profile_path=$PROFILE_PATH" >> $GITHUB_OUTPUT
          echo "export_method=$EXPORT_METHOD_FROM_PROFILE" >> $GITHUB_OUTPUT

      - name: Create export options plist
        if: steps.signing.outputs.ready == 'true'
        working-directory: immolink
        env:
          IOS_EXPORT_OPTIONS_PLIST: ${{ secrets.IOS_EXPORT_OPTIONS_PLIST }}
          IOS_EXPORT_METHOD: ${{ secrets.IOS_EXPORT_METHOD }}
          EXPORT_PROFILE_NAME: ${{ steps.signing.outputs.profile_name }}
          EXPORT_BUNDLE_ID: ${{ steps.signing.outputs.bundle_id }}
          EXPORT_TEAM_ID: ${{ steps.signing.outputs.team_id }}
          EXPORT_METHOD_FROM_PROFILE: ${{ steps.signing.outputs.export_method }}
        run: |
          set -euo pipefail
          if [ -n "$IOS_EXPORT_OPTIONS_PLIST" ]; then
            echo 'Using provided export options plist from IOS_EXPORT_OPTIONS_PLIST secret'
            printf '%s' "$IOS_EXPORT_OPTIONS_PLIST" > export-options.plist
          else
            METHOD="${IOS_EXPORT_METHOD:-${EXPORT_METHOD_FROM_PROFILE:-app-store}}"
            PROFILE_NAME="${EXPORT_PROFILE_NAME}"
            BUNDLE_ID="${EXPORT_BUNDLE_ID}"
            TEAM_ID="${EXPORT_TEAM_ID}"
            if [ -z "$PROFILE_NAME" ] || [ -z "$BUNDLE_ID" ] || [ -z "$TEAM_ID" ]; then
              echo 'Failed to resolve provisioning profile metadata for export options' >&2
              exit 1
            fi
            if [ "$METHOD" = "development" ]; then
              SIGNING_CERT="Apple Development"
            else
              SIGNING_CERT="Apple Distribution"
            fi
            {
              printf '%s\n' '<?xml version="1.0" encoding="UTF-8"?>'
              printf '%s\n' '<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">'
              printf '%s\n' '<plist version="1.0">'
              printf '%s\n' '<dict>'
              printf '%s\n' '  <key>method</key>'
              printf '  <string>%s</string>\n' "$METHOD"
              printf '%s\n' '  <key>compileBitcode</key>'
              printf '%s\n' '  <false/>'
              printf '%s\n' '  <key>provisioningProfiles</key>'
              printf '%s\n' '  <dict>'
              printf '    <key>%s</key>\n' "$BUNDLE_ID"
              printf '    <string>%s</string>\n' "$PROFILE_NAME"
              printf '%s\n' '  </dict>'
              printf '%s\n' '  <key>signingCertificate</key>'
              printf '  <string>%s</string>\n' "$SIGNING_CERT"
              printf '%s\n' '  <key>signingStyle</key>'
              printf '%s\n' '  <string>manual</string>'
              printf '%s\n' '  <key>stripSwiftSymbols</key>'
              printf '%s\n' '  <true/>'
              printf '%s\n' '  <key>teamID</key>'
              printf '  <string>%s</string>\n' "$TEAM_ID"
              printf '%s\n' '  <key>uploadSymbols</key>'
              printf '%s\n' '  <true/>'
              printf '%s\n' '</dict>'
              printf '%s\n' '</plist>'
            } > export-options.plist
          fi
          plutil -lint export-options.plist
          echo "Resolved export method: $(/usr/bin/plutil -extract method raw -o - export-options.plist 2>/dev/null || echo '?')" >&2

      - name: Build release IPA
        if: steps.signing.outputs.ready == 'true'
        working-directory: immolink
        env:
          API_URL: ${{ secrets.CLIENT_API_URL }}
          STRIPE_PUBLISHABLE_KEY: ${{ secrets.STRIPE_PUBLISHABLE_KEY }}
          GOOGLE_CLIENT_ID: ${{ secrets.GOOGLE_CLIENT_ID }}
          IOS_DEVELOPMENT_TEAM: ${{ secrets.IOS_DEVELOPMENT_TEAM }}
          IOS_BUNDLE_IDENTIFIER: ${{ secrets.IOS_BUNDLE_IDENTIFIER }}
          PROVISIONING_PROFILE_SPECIFIER: ${{ steps.signing.outputs.profile_name }}
          KEYCHAIN_PATH: ${{ steps.signing.outputs.keychain_path }}
        run: |
          set -euo pipefail
          LOG_PATH="$GITHUB_WORKSPACE/ios_workflow.log"
          : > "$LOG_PATH"
          for var in API_URL STRIPE_PUBLISHABLE_KEY GOOGLE_CLIENT_ID IOS_DEVELOPMENT_TEAM IOS_BUNDLE_IDENTIFIER; do
            if [ -z "${!var:-}" ]; then
              echo "Missing required secret: $var" >&2
              exit 1
            fi
          done
          export APPLE_DEVELOPMENT_TEAM="$IOS_DEVELOPMENT_TEAM"
          export PRODUCT_BUNDLE_IDENTIFIER="$IOS_BUNDLE_IDENTIFIER"

          # Build unsigned archive to avoid Flutter's development-certificate preflight.
          flutter build ipa --release --no-codesign \
            --no-tree-shake-icons \
            --dart-define=API_URL=$API_URL \
            --dart-define=STRIPE_PUBLISHABLE_KEY=$STRIPE_PUBLISHABLE_KEY \
            --dart-define=GOOGLE_CLIENT_ID=$GOOGLE_CLIENT_ID \
            --verbose 2>&1 | tee "$LOG_PATH"

          ARCHIVE_PATH="build/ios/archive/Runner.xcarchive"
          if [ ! -d "$ARCHIVE_PATH" ]; then
            echo "Expected archive not found: $ARCHIVE_PATH" >&2
            find build/ios -maxdepth 4 -type d -name "*.xcarchive" -print || true
            exit 1
          fi

          # Export signed IPA using the imported certificate + provisioning profile.
          EXPORT_PATH="build/ios/ipa"
          mkdir -p "$EXPORT_PATH"
          xcodebuild -exportArchive \
            -archivePath "$ARCHIVE_PATH" \
            -exportOptionsPlist export-options.plist \
            -exportPath "$EXPORT_PATH" \
            OTHER_CODE_SIGN_FLAGS="--keychain $KEYCHAIN_PATH" 2>&1 | tee -a "$LOG_PATH"

      - name: Collect IPA artifacts
        if: steps.signing.outputs.ready == 'true'
        run: |
          set -euo pipefail
          LOG_PATH="$GITHUB_WORKSPACE/ios_workflow.log"
          IPA_ROOT="immolink/build/ios/ipa"
          if [ ! -d "$IPA_ROOT" ]; then
            echo "IPA directory not found: $IPA_ROOT" >&2
            exit 1
          fi
          echo "Available IPA files:"
          find "$IPA_ROOT" -type f -name "*.ipa" -print | sed 's|^|  - |'
          mkdir -p artifacts
          VERSION="${{ steps.extract_version.outputs.app_version }}"
          PRIMARY_SOURCE=""
          if [ -f "$IPA_ROOT/Runner.ipa" ]; then
            PRIMARY_SOURCE="$IPA_ROOT/Runner.ipa"
          else
            CANDIDATE=$(find "$IPA_ROOT" -type f -name "*.ipa" | head -n1 || true)
            if [ -n "$CANDIDATE" ]; then
              PRIMARY_SOURCE="$CANDIDATE"
            fi
          fi
          if [ -z "$PRIMARY_SOURCE" ]; then
            echo "No IPA found to collect." >&2
            exit 1
          fi
          cp "$PRIMARY_SOURCE" "artifacts/immosync-ios-${VERSION}.ipa"
          cp "$PRIMARY_SOURCE" artifacts/immosync-ios-latest.ipa
          hash_file() {
            if command -v sha256sum >/dev/null 2>&1; then
              sha256sum "$1"
            else
              shasum -a 256 "$1"
            fi
          }
          hash_file "artifacts/immosync-ios-${VERSION}.ipa" > "artifacts/immosync-ios-${VERSION}.ipa.sha256"
          hash_file artifacts/immosync-ios-latest.ipa > artifacts/immosync-ios-latest.ipa.sha256
          if [ -f "$LOG_PATH" ]; then
            cp "$LOG_PATH" artifacts/ios_workflow.log
          else
            echo "Workflow log not found at $LOG_PATH" >&2
          fi
          {
            echo "version=${VERSION}";
            echo -n "primary="; basename "artifacts/immosync-ios-${VERSION}.ipa";
            echo "files="; ls -1 artifacts | sed 's/^/  - /';
          } > artifacts/BUILD_METADATA.txt
          ls -lh artifacts

      - name: Upload IPA artifact
        if: steps.signing.outputs.ready == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: immosync-ipa
          path: artifacts
          retention-days: 7

      - name: Cleanup signing assets
        if: always()
        run: |
          set -euo pipefail
          security delete-keychain build.keychain >/dev/null 2>&1 || true
          PROFILE_PATH="${{ steps.signing.outputs.profile_path }}"
          if [ -n "$PROFILE_PATH" ] && [ -f "$PROFILE_PATH" ]; then
            rm -f "$PROFILE_PATH"
          fi

  publish-to-site-repo:
    name: Push IPAs to site repository
    needs: build-ipa
    runs-on: ubuntu-latest
    if: needs.build-ipa.result == 'success' && github.ref == 'refs/heads/main'
    steps:
      - name: Check if SITE_REPO_PAT is configured
        id: check_secret
        run: |
          if [ -z "${{ secrets.SITE_REPO_PAT }}" ]; then
            echo "SITE_REPO_PAT secret is not configured. Skipping site repo publish."
            echo "skip=true" >> $GITHUB_OUTPUT
          else
            echo "skip=false" >> $GITHUB_OUTPUT
          fi

      - name: Checkout site repo
        if: steps.check_secret.outputs.skip != 'true'
        uses: actions/checkout@v4
        with:
          repository: ImmoSync-Switzerland/immosync.ch
          token: ${{ secrets.SITE_REPO_PAT }}
          fetch-depth: 0
          path: site

      - name: Download IPA artifact
        if: steps.check_secret.outputs.skip != 'true'
        uses: actions/download-artifact@v4
        with:
          name: immosync-ipa
          path: site/ipa

      - name: Prepare downloads folder
        if: steps.check_secret.outputs.skip != 'true'
        env:
          VERSION: ${{ needs.build-ipa.outputs.app_version }}
        run: |
          set -euo pipefail
          cd site
          echo "IPA directory listing (site/ipa):"; ls -lh ipa || true
          mkdir -p public/downloads/ios
          VERSION_FILE="immosync-ios-${VERSION}.ipa"
          CANDIDATES=()
          [ -f "ipa/${VERSION_FILE}" ] && CANDIDATES+=("ipa/${VERSION_FILE}")
          [ -f "ipa/immosync-ios-latest.ipa" ] && CANDIDATES+=("ipa/immosync-ios-latest.ipa")
          for f in ipa/*.ipa; do [ -f "$f" ] && CANDIDATES+=("$f"); done || true
          SEEN=""; FINAL=()
          for f in "${CANDIDATES[@]}"; do
            case " $SEEN " in *" $f "*) ;; *) SEEN="$SEEN $f"; FINAL+=("$f");; esac
          done
          if [ ${#FINAL[@]} -eq 0 ]; then
            echo "ERROR: No IPA candidates found to publish." >&2
            find ipa -maxdepth 3 -type f -printf '%P\n' || true
            exit 1
          fi
          SRC="${FINAL[0]}"
          echo "Selected IPA: $SRC"
          TARGET_VERSIONED="public/downloads/ios/${VERSION_FILE}"
          cp "$SRC" "$TARGET_VERSIONED"
          cp "$SRC" public/downloads/ios/immosync-ios-latest.ipa
          (cd public/downloads/ios && sha256sum "$(basename "$TARGET_VERSIONED")" > "${VERSION_FILE}.sha256" && sha256sum immosync-ios-latest.ipa > immosync-ios-latest.ipa.sha256)
          ls -1t public/downloads/ios/immosync-ios-*.ipa 2>/dev/null | grep -v 'latest' | tail -n +6 | xargs -r rm -f
          VERS_JSON=$(ls -1 public/downloads/ios/immosync-ios-*.ipa 2>/dev/null \
            | grep -v latest \
            | sed 's|public/downloads/ios/||' \
            | sort -r \
            | jq -R -s -c 'split("\n") | map(select(length>0))')
          echo "{\n  \"last_updated_utc\": \"$(date -u +%Y-%m-%dT%H:%M:%SZ)\",\n  \"versions\": ${VERS_JSON}\n}" > public/downloads/ios/manifest.json
          echo "Generating ios index.html"
          VLIST=$(ls -1 public/downloads/ios/immosync-ios-*.ipa 2>/dev/null | grep -v latest | sed 's|public/downloads/ios/||' | sort -r)
          {
            echo '<!doctype html><html><head><meta charset="utf-8"><title>ImmoSync iOS Downloads</title>'
            echo '<style>body{font-family:system-ui,Segoe UI,Roboto,sans-serif;padding:40px;max-width:760px;margin:auto;background:#0f172a;color:#f1f5f9}a{color:#38bdf8;text-decoration:none}a:hover{text-decoration:underline}code{background:#1e293b;padding:2px 4px;border-radius:4px}ul{line-height:1.6}</style></head><body>'
            echo '<h1>ImmoSync iOS Downloads</h1><p><a href="immosync-ios-latest.ipa">Download latest IPA</a></p><h2>Versioned builds</h2><ul>'
            for f in $VLIST; do echo "<li><a href=\"$f\">$f</a> (<a href=\"$f.sha256\">sha256</a>)</li>"; done
            echo '</ul><p>Manifest: <a href="manifest.json">manifest.json</a></p><p>Last updated: '$(date -u)'</p></body></html>'
          } > public/downloads/ios/index.html
          echo "Final downloads directory:"; ls -lh public/downloads/ios
          rm -rf ipa

      - name: Commit & push
        if: steps.check_secret.outputs.skip != 'true'
        env:
          GIT_AUTHOR_NAME: github-actions[bot]
          GIT_AUTHOR_EMAIL: 41898282+github-actions[bot]@users.noreply.github.com
          GIT_COMMITTER_NAME: github-actions[bot]
          GIT_COMMITTER_EMAIL: 41898282+github-actions[bot]@users.noreply.github.com
          VERSION: ${{ needs.build-ipa.outputs.app_version }}
        run: |
          cd site
          git config user.name "$GIT_AUTHOR_NAME"
          git config user.email "$GIT_AUTHOR_EMAIL"
          git add public/downloads/ios
          if git diff --cached --quiet; then
            echo "No changes to commit"
            exit 0
          fi
          git commit -m "chore: publish iOS IPA ${VERSION}" --no-verify
          git push

      - name: Summary
        if: steps.check_secret.outputs.skip != 'true'
        env:
          VERSION: ${{ needs.build-ipa.outputs.app_version }}
        run: |
          echo "### Cross-Repo IPA Publish" >> $GITHUB_STEP_SUMMARY
          echo "Pushed immosync-ios-${VERSION}.ipa + latest alias to site repo" >> $GITHUB_STEP_SUMMARY

  final-cleanup:
    name: Cleanup Artifacts After Publish
    runs-on: ubuntu-latest
    needs: [build-ipa, publish-to-site-repo]
    if: always()
    permissions:
      actions: write
      contents: read
    steps:
      - uses: actions/checkout@v4

      - name: Delete all build artifacts
        uses: jimschubert/delete-artifacts-action@v1
        with:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          log_level: 'error'
          min_bytes: '0'
        continue-on-error: true
