// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import 'frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they are not marked as `pub`: `get_rt`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `fmt`

/// Subscribe a Dart StreamSink to receive Matrix events.
Stream<MatrixEvent> subscribeEvents() =>
    RustLib.instance.api.crateBridgeSubscribeEvents();

Future<void> init({required String homeserver, required String dataDir}) =>
    RustLib.instance.api
        .crateBridgeInit(homeserver: homeserver, dataDir: dataDir);

Future<LoginResult> login({required String user, required String password}) =>
    RustLib.instance.api.crateBridgeLogin(user: user, password: password);

/// Create a direct message room and invite another user
/// The creator is automatically added to the room when it's created
/// If creator_mxid is provided, it will also be invited (for multi-device support)
Future<String> createRoom({required String otherMxid, String? creatorMxid}) =>
    RustLib.instance.api
        .crateBridgeCreateRoom(otherMxid: otherMxid, creatorMxid: creatorMxid);

Future<String> sendMessage({required String roomId, required String body}) =>
    RustLib.instance.api.crateBridgeSendMessage(roomId: roomId, body: body);

/// Send a read receipt for a specific event in a room.
Future<void> markRead({required String roomId, required String eventId}) =>
    RustLib.instance.api.crateBridgeMarkRead(roomId: roomId, eventId: eventId);

Future<void> startSync() => RustLib.instance.api.crateBridgeStartSync();

Future<void> stopSync() => RustLib.instance.api.crateBridgeStopSync();

class LoginResult {
  final String userId;
  final String accessToken;

  const LoginResult({
    required this.userId,
    required this.accessToken,
  });

  @override
  int get hashCode => userId.hashCode ^ accessToken.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is LoginResult &&
          runtimeType == other.runtimeType &&
          userId == other.userId &&
          accessToken == other.accessToken;
}

class MatrixEvent {
  final String roomId;
  final String eventId;
  final String sender;
  final PlatformInt64 ts;
  final String? content;
  final bool isEncrypted;

  const MatrixEvent({
    required this.roomId,
    required this.eventId,
    required this.sender,
    required this.ts,
    this.content,
    required this.isEncrypted,
  });

  @override
  int get hashCode =>
      roomId.hashCode ^
      eventId.hashCode ^
      sender.hashCode ^
      ts.hashCode ^
      content.hashCode ^
      isEncrypted.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is MatrixEvent &&
          runtimeType == other.runtimeType &&
          roomId == other.roomId &&
          eventId == other.eventId &&
          sender == other.sender &&
          ts == other.ts &&
          content == other.content &&
          isEncrypted == other.isEncrypted;
}
