// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import 'frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they are not marked as `pub`: `get_rt`

Future<void> init({required String homeserver, required String dataDir}) =>
    RustLib.instance.api
        .crateBridgeInit(homeserver: homeserver, dataDir: dataDir);

Future<LoginResult> login({required String user, required String password}) =>
    RustLib.instance.api.crateBridgeLogin(user: user, password: password);

Future<String> createRoom({required String otherMxid}) =>
    RustLib.instance.api.crateBridgeCreateRoom(otherMxid: otherMxid);

Future<String> sendMessage({required String roomId, required String body}) =>
    RustLib.instance.api.crateBridgeSendMessage(roomId: roomId, body: body);

Future<void> startSync() => RustLib.instance.api.crateBridgeStartSync();

Future<void> stopSync() => RustLib.instance.api.crateBridgeStopSync();

// Stream subscription for Matrix events
Stream<Map<String, dynamic>> subscribeEvents() async* {
    // The generated API for streams isn't present yet; after regenerating FRB
    // this will be replaced by a proper `crateBridgeSubscribeEvents()` stream.
    // Placeholder to keep API surface stable in Dart code.
    yield* const Stream.empty();
}

class LoginResult {
  final String userId;
  final String accessToken;

  const LoginResult({
    required this.userId,
    required this.accessToken,
  });

  @override
  int get hashCode => userId.hashCode ^ accessToken.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is LoginResult &&
          runtimeType == other.runtimeType &&
          userId == other.userId &&
          accessToken == other.accessToken;
}
