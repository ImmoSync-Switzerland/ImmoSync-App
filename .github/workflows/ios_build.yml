name: iOS IPA CI

on:
  push:
    paths-ignore:
      - 'public/downloads/**'
  workflow_dispatch:

jobs:
  cleanup-artifacts:
    name: Cleanup Old Artifacts
    if: ${{ false }}
    runs-on: ubuntu-latest
    permissions:
      actions: write
      contents: read
    steps:
      - uses: actions/checkout@v4

      - name: Delete old artifacts
        uses: jimschubert/delete-artifacts-action@v1
        with:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          log_level: 'error'
          min_bytes: '0'
        continue-on-error: true

  pod-install-lock:
    name: Generate Podfile.lock
    runs-on: macos-15
    if: ${{ !contains(github.event.head_commit.message || '', 'aab') }}
    # temporarily no cleanup dependency
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Select Xcode 16 (iOS 18 SDK)
        uses: maxim-lobanov/setup-xcode@v1
        with:
          xcode-version: '16'

      - name: Pod install (generate lock)
        uses: ./.github/actions/pod-install-lock
        with:
          flutter-version: '3.35.5'
          project-dir: immolink
          ios-dir: immolink/ios

      - name: Upload Podfile.lock
        uses: actions/upload-artifact@v4
        with:
          name: podfile-lock
          path: immolink/ios/Podfile.lock

      - name: Upload swizzler module debug files
        uses: actions/upload-artifact@v4
        with:
          name: pods-swizzler-debug
          path: |
            immolink/ios/Pods/GoogleUtilities/AppDelegateSwizzler/module.modulemap
            immolink/ios/Pods/GoogleUtilities/AppDelegateSwizzler/Private/GULAppDelegateSwizzler.h
            immolink/ios/Pods/Target Support Files/GoogleUtilities*/**/*.modulemap

  build-ipa:
    name: Build Release IPA
    runs-on: macos-15
    timeout-minutes: 60
    needs:
      - pod-install-lock
    if: always() && !contains(github.event.head_commit.message || '', 'aab')
    outputs:
      app_version: ${{ steps.extract_version.outputs.app_version }}

    permissions:
      contents: write
      actions: read
      checks: read
      security-events: read

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Select Xcode 16 (iOS 18 SDK)
        uses: maxim-lobanov/setup-xcode@v1
        with:
          xcode-version: '16'

      - name: Check iOS CI prerequisites
        id: prereqs
        env:
          API_URL: ${{ secrets.CLIENT_API_URL }}
          STRIPE_PUBLISHABLE_KEY: ${{ secrets.STRIPE_PUBLISHABLE_KEY }}
          GOOGLE_CLIENT_ID: ${{ secrets.GOOGLE_CLIENT_ID }}
          GOOGLE_SERVICE_INFO_PLIST: ${{ secrets.GOOGLE_SERVICE_INFO_PLIST }}
          GOOGLE_SERVICE_INFO_PLIST_B64: ${{ secrets.GOOGLE_SERVICE_INFO_PLIST_B64 }}
          IOS_CERT_P12_B64: ${{ secrets.IOS_CERT_P12_B64 }}
          IOS_CERT_PASSWORD: ${{ secrets.IOS_CERT_PASSWORD }}
          IOS_PROVISIONING_PROFILE_B64: ${{ secrets.IOS_PROVISIONING_PROFILE_B64 }}
          IOS_DEVELOPMENT_TEAM: ${{ secrets.IOS_DEVELOPMENT_TEAM }}
          IOS_BUNDLE_IDENTIFIER: ${{ secrets.IOS_BUNDLE_IDENTIFIER }}
        run: |
          set -euo pipefail
          missing=()

          for var in API_URL STRIPE_PUBLISHABLE_KEY GOOGLE_CLIENT_ID IOS_DEVELOPMENT_TEAM IOS_BUNDLE_IDENTIFIER; do
            if [ -z "${!var:-}" ]; then
              missing+=("$var")
            fi
          done

          if [ -z "${GOOGLE_SERVICE_INFO_PLIST:-}" ] && [ -z "${GOOGLE_SERVICE_INFO_PLIST_B64:-}" ]; then
            missing+=("GOOGLE_SERVICE_INFO_PLIST(_B64)")
          fi

          for var in IOS_CERT_P12_B64 IOS_CERT_PASSWORD IOS_PROVISIONING_PROFILE_B64; do
            if [ -z "${!var:-}" ]; then
              missing+=("$var")
            fi
          done

          if [ ${#missing[@]} -gt 0 ]; then
            msg="Missing required iOS secrets: ${missing[*]}"
            echo "$msg" >&2
            {
              echo "ready=false"
              echo "reason=$msg"
            } >> "$GITHUB_OUTPUT"
            echo "### iOS Build Failed" >> "$GITHUB_STEP_SUMMARY"
            echo "$msg" >> "$GITHUB_STEP_SUMMARY"
            exit 1
          fi

          echo "ready=true" >> "$GITHUB_OUTPUT"

      - name: Set up Flutter
        id: flutter-setup
        uses: subosito/flutter-action@v2
        with:
          flutter-version: '3.35.5'
          cache: true

      - name: Verify Flutter installation
        run: |
          echo "::group::Environment"
          echo "PATH=$PATH"
          echo "Home listing:"; ls -1 $HOME | head -n 50 || true
          echo "Toolcache flutter dirs:"; ls -d $HOME/hostedtoolcache/flutter* 2>/dev/null || echo 'No flutter toolcache dirs'
          echo "::endgroup::"
          if ! command -v flutter >/dev/null 2>&1; then
            echo 'Flutter not found after setup step' >&2
            exit 1
          fi
          flutter --version
          flutter doctor -v | sed -e 's/\x1b\[[0-9;]*m//g'

      - name: Flutter doctor (redundant safety)
        run: flutter doctor -v

      - name: Restore pub dependencies
        working-directory: immolink
        run: flutter pub get

      - name: Extract app version
        id: extract_version
        run: |
          VERSION_LINE=$(grep '^version:' immolink/pubspec.yaml)
          VERSION=$(echo "$VERSION_LINE" | cut -d ' ' -f2 | tr -d '\r')
          if [ -z "$VERSION" ]; then
            echo 'Unable to determine app version from pubspec.yaml' >&2
            exit 1
          fi
          echo "Detected version: $VERSION"
          echo "app_version=$VERSION" >> $GITHUB_OUTPUT

      - name: Run analyzer (warnings only)
        working-directory: immolink
        run: |
          flutter analyze || true

      - name: Validate iOS secrets (no values printed)
        if: steps.prereqs.outputs.ready == 'true'
        env:
          API_URL: ${{ secrets.CLIENT_API_URL }}
          STRIPE_PUBLISHABLE_KEY: ${{ secrets.STRIPE_PUBLISHABLE_KEY }}
          GOOGLE_CLIENT_ID: ${{ secrets.GOOGLE_CLIENT_ID }}
          GOOGLE_SERVICE_INFO_PLIST: ${{ secrets.GOOGLE_SERVICE_INFO_PLIST }}
          GOOGLE_SERVICE_INFO_PLIST_B64: ${{ secrets.GOOGLE_SERVICE_INFO_PLIST_B64 }}
          IOS_CERT_P12_B64: ${{ secrets.IOS_CERT_P12_B64 }}
          IOS_CERT_PASSWORD: ${{ secrets.IOS_CERT_PASSWORD }}
          IOS_PROVISIONING_PROFILE_B64: ${{ secrets.IOS_PROVISIONING_PROFILE_B64 }}
          IOS_DEVELOPMENT_TEAM: ${{ secrets.IOS_DEVELOPMENT_TEAM }}
          IOS_BUNDLE_IDENTIFIER: ${{ secrets.IOS_BUNDLE_IDENTIFIER }}
        run: |
          set -euo pipefail

          status_ok() { echo "[ok] $1"; }
          status_fail() { echo "[fail] $1"; exit 1; }

          # Basic presence checks (already gated, but double-check without printing values)
          for var in API_URL STRIPE_PUBLISHABLE_KEY GOOGLE_CLIENT_ID IOS_DEVELOPMENT_TEAM IOS_BUNDLE_IDENTIFIER; do
            if [ -z "${!var:-}" ]; then
              status_fail "$var is empty"
            fi
          done

          # GoogleService-Info.plist validation (raw or base64)
          gs_tmp=$(mktemp)
          if [ -n "${GOOGLE_SERVICE_INFO_PLIST_B64:-}" ]; then
            printf '%s' "$GOOGLE_SERVICE_INFO_PLIST_B64" | tr -d '\r\n' | base64 --decode > "$gs_tmp" 2>/dev/null || \
              printf '%s' "$GOOGLE_SERVICE_INFO_PLIST_B64" | tr -d '\r\n' | base64 -d > "$gs_tmp"
          elif [ -n "${GOOGLE_SERVICE_INFO_PLIST:-}" ]; then
            printf '%s' "$GOOGLE_SERVICE_INFO_PLIST" > "$gs_tmp"
          else
            status_fail "GoogleService-Info.plist secret missing"
          fi
          if ! plutil -lint "$gs_tmp" >/dev/null 2>&1; then
            status_fail "GoogleService-Info.plist failed plutil lint"
          fi
          rm -f "$gs_tmp"
          status_ok "GoogleService-Info.plist present and valid plist"

          # P12 decode + password check
          p12_tmp=$(mktemp)
          printf '%s' "$IOS_CERT_P12_B64" | tr -d '\r\n' | base64 --decode > "$p12_tmp" 2>/dev/null || \
            printf '%s' "$IOS_CERT_P12_B64" | tr -d '\r\n' | base64 -d > "$p12_tmp"
          if ! openssl pkcs12 -in "$p12_tmp" -passin pass:"$IOS_CERT_PASSWORD" -info -nokeys >/dev/null 2>&1; then
            status_fail "PKCS12 failed to open with provided password"
          fi
          rm -f "$p12_tmp"
          status_ok "PKCS12 decodes and password accepted"

          # Provisioning profile decode + plist parse
          profile_tmp=$(mktemp)
          printf '%s' "$IOS_PROVISIONING_PROFILE_B64" | tr -d '\r\n' | base64 --decode > "$profile_tmp" 2>/dev/null || \
            printf '%s' "$IOS_PROVISIONING_PROFILE_B64" | tr -d '\r\n' | base64 -d > "$profile_tmp"
          if ! security cms -D -i "$profile_tmp" >/dev/null 2>&1; then
            status_fail "Provisioning profile failed CMS decode"
          fi
          status_ok "Provisioning profile decodes"
          rm -f "$profile_tmp"

          {
            echo "## iOS secret validation"
            echo "- API_URL / STRIPE_PUBLISHABLE_KEY / GOOGLE_CLIENT_ID: present"
            echo "- GOOGLE_SERVICE_INFO_PLIST(_B64): valid plist"
            echo "- IOS_CERT_P12_B64: decodes with password"
            echo "- IOS_PROVISIONING_PROFILE_B64: CMS decode ok"
            echo "- IOS_DEVELOPMENT_TEAM / IOS_BUNDLE_IDENTIFIER: present"
          } >> "$GITHUB_STEP_SUMMARY"

      - name: Create .env file from secrets
        if: steps.prereqs.outputs.ready == 'true'
        working-directory: immolink
        env:
          API_URL: ${{ secrets.CLIENT_API_URL }}
          STRIPE_PUBLISHABLE_KEY: ${{ secrets.STRIPE_PUBLISHABLE_KEY }}
          GOOGLE_CLIENT_ID: ${{ secrets.GOOGLE_CLIENT_ID }}
          MONGODB_URI: ${{ secrets.MONGODB_URI }}
          MONGODB_DB_NAME: ${{ secrets.MONGODB_DB_NAME }}
          WS_URL: ${{ secrets.WS_URL }}
        run: |
          echo "Creating .env file for flutter_dotenv..."
          cat > .env << EOF
          API_URL=${API_URL}
          STRIPE_PUBLISHABLE_KEY=${STRIPE_PUBLISHABLE_KEY}
          GOOGLE_CLIENT_ID=${GOOGLE_CLIENT_ID}
          MONGODB_URI=${MONGODB_URI:-}
          MONGODB_DB_NAME=${MONGODB_DB_NAME:-}
          WS_URL=${WS_URL:-}
          EOF
          echo ".env file created with $(wc -l < .env) lines"

      - name: Create GoogleService-Info.plist from secret
        if: steps.prereqs.outputs.ready == 'true'
        working-directory: immolink/ios/Runner
        env:
          GOOGLE_SERVICE_INFO_PLIST: ${{ secrets.GOOGLE_SERVICE_INFO_PLIST }}
          GOOGLE_SERVICE_INFO_PLIST_B64: ${{ secrets.GOOGLE_SERVICE_INFO_PLIST_B64 }}
        run: |
          RAW_SECRET="$GOOGLE_SERVICE_INFO_PLIST"
          B64_SECRET="$GOOGLE_SERVICE_INFO_PLIST_B64"
          if [ -n "$B64_SECRET" ]; then
            echo 'Using base64-encoded GoogleService-Info.plist secret'
            printf '%s' "$B64_SECRET" | tr -d '\r\n' | base64 --decode > GoogleService-Info.plist 2>/dev/null || \
              printf '%s' "$B64_SECRET" | tr -d '\r\n' | base64 -d > GoogleService-Info.plist
          elif [ -n "$RAW_SECRET" ]; then
            echo 'Using raw GoogleService-Info.plist secret'
            printf '%s' "$RAW_SECRET" > GoogleService-Info.plist
          else
            echo 'Missing required secret: provide either GOOGLE_SERVICE_INFO_PLIST (raw plist) or GOOGLE_SERVICE_INFO_PLIST_B64 (base64)' >&2
            exit 1
          fi
          plutil -lint GoogleService-Info.plist

      - name: Install CocoaPods dependencies (clean)
        if: steps.prereqs.outputs.ready == 'true'
        working-directory: immolink/ios
        run: |
          set -euo pipefail
          rm -rf Pods Podfile.lock
          pod --version
          pod install --repo-update

      - name: Dump GoogleUtilities modulemaps (debug)
        if: steps.prereqs.outputs.ready == 'true'
        working-directory: immolink/ios
        run: |
          set -euo pipefail
          echo "== GoogleUtilities.modulemap =="
          cat Pods/Target\ Support\ Files/GoogleUtilities/GoogleUtilities.modulemap || true
          echo "== SceneDelegateSwizzler modulemaps =="
          find Pods/Target\ Support\ Files -iname '*SceneDelegateSwizzler*.modulemap' -print -exec cat {} \; || true
          echo "== AppDelegateSwizzler modulemaps =="
          find Pods/Target\ Support\ Files -iname '*AppDelegateSwizzler*.modulemap' -print -exec cat {} \; || true
          echo "== Grep for GULSceneDelegateSwizzler across Target Support Files =="
          grep -R "GULSceneDelegateSwizzler" "Pods/Target Support Files" -n || true
          echo "== Grep for GULSceneDelegateSwizzler across Pods/GoogleUtilities =="
          grep -R "GULSceneDelegateSwizzler" Pods/GoogleUtilities -n || true

      - name: Verify GoogleUtilities AppDelegateSwizzler module
        if: steps.prereqs.outputs.ready == 'true'
        working-directory: immolink/ios
        run: |
          set -euo pipefail
          # CocoaPods usually builds GoogleUtilities as a single module (GoogleUtilities) even when a
          # subspec like AppDelegateSwizzler is explicitly requested. Some toolchains may also expose
          # an underscore-style module name (GoogleUtilities_AppDelegateSwizzler), so accept either.
          if grep -R --line-number --fixed-strings "module GoogleUtilities_AppDelegateSwizzler" "Pods/Target Support Files" "Pods" >/dev/null 2>&1; then
            echo "Found module declaration for GoogleUtilities_AppDelegateSwizzler"
            exit 0
          fi

          gu_modulemap="Pods/Target Support Files/GoogleUtilities/GoogleUtilities.modulemap"
          if [ -f "$gu_modulemap" ] && grep -nE "GULAppDelegateSwizzler|AppDelegateSwizzler" "$gu_modulemap" >/dev/null 2>&1; then
            echo "Found AppDelegateSwizzler references in $gu_modulemap"
            exit 0
          fi

          if find Pods -type f -iname 'GULAppDelegateSwizzler*.h' -print -quit 2>/dev/null | grep -q .; then
            echo "Found GULAppDelegateSwizzler header under Pods/"
            exit 0
          fi

          candidates="$(find Pods -type f -iname '*appdelegateswizzler*.modulemap' -print || true)"
          if [ -n "${candidates:-}" ]; then
            echo "Found AppDelegateSwizzler modulemap candidate(s):"
            echo "$candidates"
            echo "Contents preview (first match):"
            first="$(echo "$candidates" | head -n1)"
            sed -n '1,80p' "$first" || true
            exit 0
          fi

          echo "Missing GoogleUtilities AppDelegateSwizzler modulemap after pod install" >&2
          echo "AppDelegateSwizzler-related files found under Pods/:" >&2
          find Pods -maxdepth 6 -iname '*appdelegateswizzler*' -print || true
          echo "Pods/Target Support Files listing (top-level):" >&2
          find "Pods/Target Support Files" -maxdepth 2 -type f -name "*.modulemap" -print | head -n 50 || true
          exit 1

      - name: Prepare signing assets
        id: signing
        if: steps.prereqs.outputs.ready == 'true'
        env:
          IOS_CERT_P12_B64: ${{ secrets.IOS_CERT_P12_B64 }}
          IOS_CERT_PASSWORD: ${{ secrets.IOS_CERT_PASSWORD }}
          IOS_PROVISIONING_PROFILE_B64: ${{ secrets.IOS_PROVISIONING_PROFILE_B64 }}
          IOS_DEVELOPMENT_TEAM: ${{ secrets.IOS_DEVELOPMENT_TEAM }}
          IOS_BUNDLE_IDENTIFIER: ${{ secrets.IOS_BUNDLE_IDENTIFIER }}
        run: |
          set -euo pipefail
          if [ -z "$IOS_CERT_P12_B64" ] || [ -z "$IOS_CERT_PASSWORD" ] || [ -z "$IOS_PROVISIONING_PROFILE_B64" ]; then
            echo 'Missing required signing secrets: IOS_CERT_P12_B64, IOS_CERT_PASSWORD, IOS_PROVISIONING_PROFILE_B64' >&2
            echo "ready=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          decode_b64() {
            # Accept base64 with or without newlines/CRLF; avoid echo quirks with leading '-' sequences.
            local input="$1"
            local output="$2"
            printf '%s' "$input" | tr -d '\r\n' | base64 --decode > "$output" 2>/dev/null || \
              printf '%s' "$input" | tr -d '\r\n' | base64 -d > "$output"
          }

          CERT_PASSWORD="$(printf '%s' "$IOS_CERT_PASSWORD" | tr -d '\r\n')"

          KEYCHAIN_PASSWORD=$(openssl rand -base64 32)
          KEYCHAIN_PATH=$HOME/Library/Keychains/build.keychain-db
          security create-keychain -p "$KEYCHAIN_PASSWORD" build.keychain
          security set-keychain-settings -lut 21600 build.keychain
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" build.keychain
          security list-keychains -d user -s build.keychain $(security list-keychains -d user | tr -d '"')
          security default-keychain -d user -s build.keychain

          decode_b64 "$IOS_CERT_P12_B64" signing_cert.p12
          if ! openssl pkcs12 -in signing_cert.p12 -passin pass:"$CERT_PASSWORD" -info -nokeys >/dev/null 2>&1; then
            echo 'PKCS12 validation failed: check IOS_CERT_P12_B64 is the full base64 of a .p12 and IOS_CERT_PASSWORD matches the .p12 password.' >&2
            exit 1
          fi
          if ! security import signing_cert.p12 -f pkcs12 -k build.keychain -P "$CERT_PASSWORD" -T /usr/bin/codesign -T /usr/bin/security; then
            echo 'Initial PKCS12 import failed; attempting to re-pack .p12 into legacy format for macOS Keychain import...' >&2
            echo "OpenSSL: $(openssl version)" >&2

            repack_err="$(mktemp)"
            repack_pem="$(mktemp)"
            # Re-pack using older algorithms that Keychain commonly accepts (works even when OpenSSL lacks `-legacy`).
            if ! openssl pkcs12 -in signing_cert.p12 -passin pass:"$CERT_PASSWORD" -nodes -out "$repack_pem" >/dev/null 2>"$repack_err"; then
              echo 'Failed to unpack PKCS12 for repack; OpenSSL output:' >&2
              sed -n '1,60p' "$repack_err" >&2 || true
              rm -f "$repack_err" "$repack_pem"
              exit 1
            fi
            if ! openssl pkcs12 -export -in "$repack_pem" -out signing_cert_legacy.p12 -passout pass:"$CERT_PASSWORD" -certpbe PBE-SHA1-3DES -keypbe PBE-SHA1-3DES -macalg sha1 >/dev/null 2>"$repack_err"; then
              echo 'Failed to re-pack PKCS12 into legacy algorithms; OpenSSL output:' >&2
              sed -n '1,60p' "$repack_err" >&2 || true
              rm -f "$repack_err" "$repack_pem"
              exit 1
            fi
            rm -f "$repack_err" "$repack_pem"
            if [ ! -s signing_cert_legacy.p12 ]; then
              echo 'Failed to generate legacy PKCS12; re-export the .p12 from Keychain Access (must include the private key) and re-upload secrets.' >&2
              exit 1
            fi
            security import signing_cert_legacy.p12 -f pkcs12 -k build.keychain -P "$CERT_PASSWORD" -T /usr/bin/codesign -T /usr/bin/security
            rm -f signing_cert_legacy.p12
          fi
          rm -f signing_cert.p12
          security set-key-partition-list -S apple-tool:,apple: -s -k "$KEYCHAIN_PASSWORD" build.keychain

          PROFILE_DIR="$HOME/Library/MobileDevice/Provisioning Profiles"
          mkdir -p "$PROFILE_DIR"
          PROFILE_PATH="$PROFILE_DIR/Immolink.mobileprovision"
          decode_b64 "$IOS_PROVISIONING_PROFILE_B64" "$PROFILE_PATH"

          PROFILE_PLIST=$(mktemp)
          security cms -D -i "$PROFILE_PATH" > "$PROFILE_PLIST"
          PROFILE_NAME=$(/usr/libexec/PlistBuddy -c "Print :Name" "$PROFILE_PLIST")
          PROFILE_UUID=$(/usr/libexec/PlistBuddy -c "Print :UUID" "$PROFILE_PLIST")
          PROFILE_APP_ID=$(/usr/libexec/PlistBuddy -c "Print :Entitlements:application-identifier" "$PROFILE_PLIST" 2>/dev/null || true)
          PROFILE_GET_TASK_ALLOW=$(/usr/libexec/PlistBuddy -c "Print :Entitlements:get-task-allow" "$PROFILE_PLIST" 2>/dev/null || true)
          PROFILE_HAS_DEVICES=$(/usr/libexec/PlistBuddy -c "Print :ProvisionedDevices" "$PROFILE_PLIST" 2>/dev/null >/dev/null && echo "true" || echo "false")
          PROFILE_PROVISIONS_ALL_DEVICES=$(/usr/libexec/PlistBuddy -c "Print :ProvisionsAllDevices" "$PROFILE_PLIST" 2>/dev/null || true)
          rm -f "$PROFILE_PLIST"

          if [ -z "$PROFILE_NAME" ] || [ -z "$PROFILE_UUID" ] || [ -z "$PROFILE_APP_ID" ]; then
            echo 'Unable to read provisioning profile metadata (Name/UUID/Application Identifier)' >&2
            exit 1
          fi

          PROFILE_TEAM_ID="${PROFILE_APP_ID%%.*}"
          if [ "$PROFILE_TEAM_ID" = "$PROFILE_APP_ID" ]; then
            PROFILE_TEAM_ID=""
          fi
          PROFILE_BUNDLE_ID="${PROFILE_APP_ID#*.}"
          if [ "$PROFILE_BUNDLE_ID" = "$PROFILE_APP_ID" ]; then
            PROFILE_BUNDLE_ID="$PROFILE_APP_ID"
          fi

          if [ -n "${IOS_DEVELOPMENT_TEAM:-}" ] && [ -n "$PROFILE_TEAM_ID" ] && [ "$IOS_DEVELOPMENT_TEAM" != "$PROFILE_TEAM_ID" ]; then
            echo "Provisioning profile team ID ($PROFILE_TEAM_ID) does not match IOS_DEVELOPMENT_TEAM ($IOS_DEVELOPMENT_TEAM)" >&2
            exit 1
          fi

          if [ -n "${IOS_BUNDLE_IDENTIFIER:-}" ] && [ "$IOS_BUNDLE_IDENTIFIER" != "$PROFILE_BUNDLE_ID" ]; then
            echo "Provisioning profile bundle identifier ($PROFILE_BUNDLE_ID) does not match IOS_BUNDLE_IDENTIFIER ($IOS_BUNDLE_IDENTIFIER)" >&2
            exit 1
          fi

          TEAM_ID="${IOS_DEVELOPMENT_TEAM:-$PROFILE_TEAM_ID}"
          if [ -z "$TEAM_ID" ]; then
            echo 'Unable to determine Apple development team ID from secrets or profile' >&2
            exit 1
          fi

          # Derive an export method suggestion based on profile type unless explicitly provided later.
          # - development: get-task-allow == true
          # - enterprise: ProvisionsAllDevices == true
          # - ad-hoc: has ProvisionedDevices array
          # - app-store: default
          EXPORT_METHOD_FROM_PROFILE="app-store"
          if [ "${PROFILE_GET_TASK_ALLOW:-}" = "true" ]; then
            EXPORT_METHOD_FROM_PROFILE="development"
          elif [ "${PROFILE_PROVISIONS_ALL_DEVICES:-}" = "true" ]; then
            EXPORT_METHOD_FROM_PROFILE="enterprise"
          elif [ "${PROFILE_HAS_DEVICES:-}" = "true" ]; then
            EXPORT_METHOD_FROM_PROFILE="ad-hoc"
          fi

          echo "ready=true" >> $GITHUB_OUTPUT
          echo "::add-mask::$KEYCHAIN_PASSWORD"
          echo "keychain_password=$KEYCHAIN_PASSWORD" >> $GITHUB_OUTPUT
          echo "keychain_path=$KEYCHAIN_PATH" >> $GITHUB_OUTPUT
          echo "::add-mask::$PROFILE_UUID"
          echo "::add-mask::$TEAM_ID"
          echo "profile_name=$PROFILE_NAME" >> $GITHUB_OUTPUT
          echo "profile_uuid=$PROFILE_UUID" >> $GITHUB_OUTPUT
          echo "bundle_id=$PROFILE_BUNDLE_ID" >> $GITHUB_OUTPUT
          echo "team_id=$TEAM_ID" >> $GITHUB_OUTPUT
          echo "profile_path=$PROFILE_PATH" >> $GITHUB_OUTPUT
          echo "export_method=$EXPORT_METHOD_FROM_PROFILE" >> $GITHUB_OUTPUT

      - name: Create export options plist
        if: steps.signing.outputs.ready == 'true'
        working-directory: immolink
        env:
          IOS_EXPORT_OPTIONS_PLIST: ${{ secrets.IOS_EXPORT_OPTIONS_PLIST }}
          IOS_EXPORT_METHOD: ${{ secrets.IOS_EXPORT_METHOD }}
          EXPORT_PROFILE_NAME: ${{ steps.signing.outputs.profile_name }}
          EXPORT_BUNDLE_ID: ${{ steps.signing.outputs.bundle_id }}
          EXPORT_TEAM_ID: ${{ steps.signing.outputs.team_id }}
          EXPORT_METHOD_FROM_PROFILE: ${{ steps.signing.outputs.export_method }}
        run: |
          set -euo pipefail
          if [ -n "$IOS_EXPORT_OPTIONS_PLIST" ]; then
            echo 'Using provided export options plist from IOS_EXPORT_OPTIONS_PLIST secret'
            printf '%s' "$IOS_EXPORT_OPTIONS_PLIST" > export-options.plist
          else
            METHOD="${IOS_EXPORT_METHOD:-${EXPORT_METHOD_FROM_PROFILE:-app-store}}"
            PROFILE_NAME="${EXPORT_PROFILE_NAME}"
            BUNDLE_ID="${EXPORT_BUNDLE_ID}"
            TEAM_ID="${EXPORT_TEAM_ID}"
            if [ -z "$PROFILE_NAME" ] || [ -z "$BUNDLE_ID" ] || [ -z "$TEAM_ID" ]; then
              echo 'Failed to resolve provisioning profile metadata for export options' >&2
              exit 1
            fi
            if [ "$METHOD" = "development" ]; then
              SIGNING_CERT="Apple Development"
            else
              SIGNING_CERT="Apple Distribution"
            fi
            {
              printf '%s\n' '<?xml version="1.0" encoding="UTF-8"?>'
              printf '%s\n' '<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">'
              printf '%s\n' '<plist version="1.0">'
              printf '%s\n' '<dict>'
              printf '%s\n' '  <key>method</key>'
              printf '  <string>%s</string>\n' "$METHOD"
              printf '%s\n' '  <key>compileBitcode</key>'
              printf '%s\n' '  <false/>'
              printf '%s\n' '  <key>provisioningProfiles</key>'
              printf '%s\n' '  <dict>'
              printf '    <key>%s</key>\n' "$BUNDLE_ID"
              printf '    <string>%s</string>\n' "$PROFILE_NAME"
              printf '%s\n' '  </dict>'
              printf '%s\n' '  <key>signingCertificate</key>'
              printf '  <string>%s</string>\n' "$SIGNING_CERT"
              printf '%s\n' '  <key>signingStyle</key>'
              printf '%s\n' '  <string>manual</string>'
              printf '%s\n' '  <key>stripSwiftSymbols</key>'
              printf '%s\n' '  <true/>'
              printf '%s\n' '  <key>teamID</key>'
              printf '  <string>%s</string>\n' "$TEAM_ID"
              printf '%s\n' '  <key>uploadSymbols</key>'
              printf '%s\n' '  <true/>'
              printf '%s\n' '</dict>'
              printf '%s\n' '</plist>'
            } > export-options.plist
          fi
          plutil -lint export-options.plist
          echo "Resolved export method: $(/usr/bin/plutil -extract method raw -o - export-options.plist 2>/dev/null || echo '?')" >&2

      - name: Build release IPA
        if: steps.signing.outputs.ready == 'true'
        working-directory: immolink
        env:
          API_URL: ${{ secrets.CLIENT_API_URL }}
          STRIPE_PUBLISHABLE_KEY: ${{ secrets.STRIPE_PUBLISHABLE_KEY }}
          GOOGLE_CLIENT_ID: ${{ secrets.GOOGLE_CLIENT_ID }}
          IOS_DEVELOPMENT_TEAM: ${{ secrets.IOS_DEVELOPMENT_TEAM }}
          IOS_BUNDLE_IDENTIFIER: ${{ secrets.IOS_BUNDLE_IDENTIFIER }}
          PROVISIONING_PROFILE_SPECIFIER: ${{ steps.signing.outputs.profile_name }}
          KEYCHAIN_PATH: ${{ steps.signing.outputs.keychain_path }}
        run: |
          set -euo pipefail
          LOG_PATH="$GITHUB_WORKSPACE/ios_workflow.log"
          : > "$LOG_PATH"
          for var in API_URL STRIPE_PUBLISHABLE_KEY GOOGLE_CLIENT_ID IOS_DEVELOPMENT_TEAM IOS_BUNDLE_IDENTIFIER; do
            if [ -z "${!var:-}" ]; then
              echo "Missing required secret: $var" >&2
              exit 1
            fi
          done
          export APPLE_DEVELOPMENT_TEAM="$IOS_DEVELOPMENT_TEAM"
          export PRODUCT_BUNDLE_IDENTIFIER="$IOS_BUNDLE_IDENTIFIER"

          # Build unsigned archive to avoid Flutter's development-certificate preflight.
          flutter build ipa --release --no-codesign \
            --no-tree-shake-icons \
            --dart-define=API_URL=$API_URL \
            --dart-define=STRIPE_PUBLISHABLE_KEY=$STRIPE_PUBLISHABLE_KEY \
            --dart-define=GOOGLE_CLIENT_ID=$GOOGLE_CLIENT_ID \
            --verbose 2>&1 | tee "$LOG_PATH"

          ARCHIVE_PATH="build/ios/archive/Runner.xcarchive"
          if [ ! -d "$ARCHIVE_PATH" ]; then
            echo "Expected archive not found: $ARCHIVE_PATH" >&2
            find build/ios -maxdepth 4 -type d -name "*.xcarchive" -print || true
            exit 1
          fi

          # Export signed IPA using the imported certificate + provisioning profile.
          EXPORT_PATH="build/ios/ipa"
          mkdir -p "$EXPORT_PATH"
          xcodebuild -exportArchive \
            -archivePath "$ARCHIVE_PATH" \
            -exportOptionsPlist export-options.plist \
            -exportPath "$EXPORT_PATH" \
            OTHER_CODE_SIGN_FLAGS="--keychain $KEYCHAIN_PATH" 2>&1 | tee -a "$LOG_PATH"

      - name: Collect IPA artifacts
        if: steps.signing.outputs.ready == 'true'
        run: |
          set -euo pipefail
          LOG_PATH="$GITHUB_WORKSPACE/ios_workflow.log"
          IPA_ROOT="immolink/build/ios/ipa"
          if [ ! -d "$IPA_ROOT" ]; then
            echo "IPA directory not found: $IPA_ROOT" >&2
            exit 1
          fi
          echo "Available IPA files:"
          find "$IPA_ROOT" -type f -name "*.ipa" -print | sed 's|^|  - |'
          mkdir -p artifacts
          VERSION="${{ steps.extract_version.outputs.app_version }}"
          PRIMARY_SOURCE=""
          if [ -f "$IPA_ROOT/Runner.ipa" ]; then
            PRIMARY_SOURCE="$IPA_ROOT/Runner.ipa"
          else
            CANDIDATE=$(find "$IPA_ROOT" -type f -name "*.ipa" | head -n1 || true)
            if [ -n "$CANDIDATE" ]; then
              PRIMARY_SOURCE="$CANDIDATE"
            fi
          fi
          if [ -z "$PRIMARY_SOURCE" ]; then
            echo "No IPA found to collect." >&2
            exit 1
          fi
          cp "$PRIMARY_SOURCE" "artifacts/immosync-ios-${VERSION}.ipa"
          cp "$PRIMARY_SOURCE" artifacts/immosync-ios-latest.ipa
          hash_file() {
            if command -v sha256sum >/dev/null 2>&1; then
              sha256sum "$1"
            else
              shasum -a 256 "$1"
            fi
          }
          hash_file "artifacts/immosync-ios-${VERSION}.ipa" > "artifacts/immosync-ios-${VERSION}.ipa.sha256"
          hash_file artifacts/immosync-ios-latest.ipa > artifacts/immosync-ios-latest.ipa.sha256
          if [ -f "$LOG_PATH" ]; then
            cp "$LOG_PATH" artifacts/ios_workflow.log
          else
            echo "Workflow log not found at $LOG_PATH" >&2
          fi
          {
            echo "version=${VERSION}";
            echo -n "primary="; basename "artifacts/immosync-ios-${VERSION}.ipa";
            echo "files="; ls -1 artifacts | sed 's/^/  - /';
          } > artifacts/BUILD_METADATA.txt
          ls -lh artifacts

      - name: Upload IPA artifact
        if: steps.signing.outputs.ready == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: immosync-ipa
          path: artifacts
          retention-days: 7

      - name: Cleanup signing assets
        if: always()
        run: |
          set -euo pipefail
          security delete-keychain build.keychain >/dev/null 2>&1 || true
          PROFILE_PATH="${{ steps.signing.outputs.profile_path }}"
          if [ -n "$PROFILE_PATH" ] && [ -f "$PROFILE_PATH" ]; then
            rm -f "$PROFILE_PATH"
          fi

  upload-testflight:
    name: Upload IPA to App Store Connect (TestFlight)
    needs: build-ipa
    runs-on: macos-15
    if: needs.build-ipa.result == 'success'
    steps:
      - name: Select Xcode 16 (iOS 18 SDK)
        uses: maxim-lobanov/setup-xcode@v1
        with:
          xcode-version: '16'

      - name: Check App Store Connect API secrets
        env:
          ASC_KEY_ID: ${{ secrets.APP_STORE_CONNECT_API_KEY_ID }}
          ASC_ISSUER_ID: ${{ secrets.APP_STORE_CONNECT_API_ISSUER_ID }}
          ASC_KEY_B64: ${{ secrets.APP_STORE_CONNECT_API_KEY_BASE64 }}
        run: |
          set -euo pipefail
          missing=()
          [ -z "${ASC_KEY_ID:-}" ] && missing+=(APP_STORE_CONNECT_API_KEY_ID)
          [ -z "${ASC_ISSUER_ID:-}" ] && missing+=(APP_STORE_CONNECT_API_ISSUER_ID)
          [ -z "${ASC_KEY_B64:-}" ] && missing+=(APP_STORE_CONNECT_API_KEY_BASE64)
          if [ ${#missing[@]} -gt 0 ]; then
            echo "Missing App Store Connect API secrets: ${missing[*]}" >&2
            exit 1
          fi

      - name: Download IPA artifact
        uses: actions/download-artifact@v4
        with:
          name: immosync-ipa
          path: ipa

      - name: Select IPA
        id: select_ipa
        run: |
          set -euo pipefail
          IPA_PATH=$(find ipa -name '*.ipa' -print | head -n 1)
          if [ -z "$IPA_PATH" ]; then
            echo 'No IPA found in artifact download' >&2
            find ipa -maxdepth 3 -type f -print || true
            exit 1
          fi
          echo "Using IPA: $IPA_PATH"
          echo "ipa_path=$IPA_PATH" >> "$GITHUB_OUTPUT"

      - name: Write App Store Connect API key file
        id: write_key
        env:
          ASC_KEY_B64: ${{ secrets.APP_STORE_CONNECT_API_KEY_BASE64 }}
          ASC_KEY_ID: ${{ secrets.APP_STORE_CONNECT_API_KEY_ID }}
        run: |
          set -euo pipefail
          KEY_DIR="$HOME/.appstoreconnect/private_keys"
          mkdir -p "$KEY_DIR"
          KEY_PATH="$KEY_DIR/AuthKey_${ASC_KEY_ID}.p8"
          printf '%s' "$ASC_KEY_B64" | tr -d '\r\n' | base64 --decode > "$KEY_PATH" 2>/dev/null || \
            printf '%s' "$ASC_KEY_B64" | tr -d '\r\n' | base64 -d > "$KEY_PATH"
          chmod 600 "$KEY_PATH"
          echo "key_path=$KEY_PATH" >> "$GITHUB_OUTPUT"

      - name: Upload to App Store Connect via altool
        env:
          ASC_KEY_ID: ${{ secrets.APP_STORE_CONNECT_API_KEY_ID }}
          ASC_ISSUER_ID: ${{ secrets.APP_STORE_CONNECT_API_ISSUER_ID }}
        run: |
          set -euo pipefail
          IPA_PATH="${{ steps.select_ipa.outputs.ipa_path }}"
          KEY_PATH="${{ steps.write_key.outputs.key_path }}"
          if [ ! -f "$IPA_PATH" ]; then
            echo "IPA not found at $IPA_PATH" >&2
            exit 1
          fi
          if [ ! -f "$KEY_PATH" ]; then
            echo "API key file missing at $KEY_PATH" >&2
            exit 1
          fi
          xcrun altool --upload-app -t ios -f "$IPA_PATH" --apiKey "$ASC_KEY_ID" --apiIssuer "$ASC_ISSUER_ID" --verbose
          echo "Upload submitted to App Store Connect (TestFlight pipeline)"

  final-cleanup:
    name: Cleanup Artifacts After Publish
    runs-on: ubuntu-latest
    needs: [build-ipa, upload-testflight]
    if: always()
    permissions:
      actions: write
      contents: read
    steps:
      - uses: actions/checkout@v4

      - name: Delete all build artifacts
        uses: jimschubert/delete-artifacts-action@v1
        with:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          log_level: 'error'
          min_bytes: '0'
        continue-on-error: true
