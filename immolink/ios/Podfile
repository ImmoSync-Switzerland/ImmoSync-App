platform :ios, '15.0'

# Explicitly load installer types to avoid CocoaPods 1.16+ NameError on Ruby 3.3 runners
require 'cocoapods/installer/installation_options'

# CocoaPods analytics sends network stats synchronously affecting flutter build latency.
ENV['COCOAPODS_DISABLE_STATS'] = 'true'
# Some pods (e.g., Stripe) can fail when shallow-cloned on CI runners; force full clones to avoid tag lookup errors.
ENV['COCOAPODS_DISABLE_GIT_DEPTH'] = 'true'
require 'shellwords'

project 'Runner', {
  'Debug' => :debug,
  'Profile' => :release,
  'Release' => :release,
}

def flutter_root
  generated_xcode_build_settings_path = File.expand_path(File.join('..', 'Flutter', 'Generated.xcconfig'), __FILE__)
  unless File.exist?(generated_xcode_build_settings_path)
    raise "#{generated_xcode_build_settings_path} must exist. If you're running pod install manually, run:\n  flutter pub get\n  flutter precache --ios\n"
  end

  File.foreach(generated_xcode_build_settings_path) do |line|
    matches = line.match(/FLUTTER_ROOT\=(.*)/)
    return matches[1].strip if matches
  end
  raise "FLUTTER_ROOT not found in #{generated_xcode_build_settings_path}. Try deleting Flutter/Generated.xcconfig and run flutter pub get."
end

require File.expand_path(File.join('packages', 'flutter_tools', 'bin', 'podhelper'), flutter_root)

flutter_ios_podfile_setup

target 'Runner' do
  # FlutterFire recommends static frameworks to avoid Swift module import issues (e.g. GoogleUtilities_AppDelegateSwizzler).
  $FirebaseAsStaticFramework = true
  use_frameworks! :linkage => :static
  use_modular_headers!

  # Use GTMSessionFetcher default pod (no custom modulemap overrides).
  pod 'GTMSessionFetcher'

  # Ensure GoogleUtilities is built with a module and all required swizzler bits.
  # Use latest GoogleUtilities compatible with Firebase (removes missing subspec issues)
  pod 'GoogleUtilities', :subspecs => [
    'AppDelegateSwizzler',
    'MethodSwizzler',
    'Environment',
    'Network',
    'NSData+zlib',
    'Logger',
    'UserDefaults'
  ]

  flutter_install_all_ios_pods File.dirname(File.realpath(__FILE__))
end

post_install do |installer|
  # CocoaPods 1.16+ drops installer.platform_name; provide a safe shim to keep older hooks working.
  installer.define_singleton_method(:platform_name) do
    pods_project.targets.map { |t| t.respond_to?(:platform_name) ? t.platform_name : nil }.compact.first || :ios
  end unless installer.respond_to?(:platform_name)

  # CocoaPods 1.16+ also removes installer.deployment_target; provide a shim for Flutter's podhelper.
  installer.define_singleton_method(:deployment_target) do
    # Prefer the Podfile platform if available, else fall back to 15.0 (our declared platform)
    platform = installer.podfile.target_definition_list.map(&:platform).compact.first
    if platform.respond_to?(:deployment_target)
      platform.deployment_target.to_s
    else
      '15.0'
    end
  end unless installer.respond_to?(:deployment_target)

  installer.pods_project.targets.each do |target|
    target.build_configurations.each do |config|
      config.build_settings['IPHONEOS_DEPLOYMENT_TARGET'] = '15.0'
      flags = Array(config.build_settings['OTHER_SWIFT_FLAGS']).dup
      flags << '-enable-experimental-feature' << 'AccessLevelOnImport'
      config.build_settings['OTHER_SWIFT_FLAGS'] = flags

      # Ensure modules are emitted for GoogleUtilities and GTMSessionFetcher pods.
      if target.name.include?('GoogleUtilities') || target.name.include?('GTMSessionFetcher')
        config.build_settings['DEFINES_MODULE'] = 'YES'
        config.build_settings['CLANG_ENABLE_MODULES'] = 'YES'
      end
    end
    flutter_additional_ios_build_settings(target)
  end

  # Ensure dedicated modulemaps exist for GoogleUtilities subspecs Firebase imports with underscore modules.
  gu_subspecs = {
    'AppDelegateSwizzler' => ['GULAppDelegateSwizzler.h'],
    'SceneDelegateSwizzler' => ['GULSceneDelegateSwizzler.h'],
    'Environment' => ['GULEnvironment.h', 'GULAppEnvironmentUtil.h', 'GULAppEnvironmentUtil_Private.h'],
    'MethodSwizzler' => ['GULSwizzler.h'],
    'Logger' => ['GULLogger.h'],
    'Network' => ['GULNetwork.h'],
    'NSData+zlib' => ['GULNSData+zlib.h'],
    'UserDefaults' => ['GULUserDefaults.h']
  }

  resolve_header = lambda do |names|
    Array(names).each do |name|
      path = Dir.glob(File.join(installer.sandbox.root, 'GoogleUtilities', '**', name)).first
      return path if path && File.exist?(path)
    end
    nil
  end

  gu_subspecs.each do |subspec, header_names|
    header_path = resolve_header.call(header_names)
    next unless header_path && File.exist?(header_path)

    sanitized = subspec.gsub(/[^A-Za-z0-9_]/, '_')
    ts_dir = File.join(installer.sandbox.root, 'Target Support Files', "GoogleUtilities-#{subspec}")
    FileUtils.mkdir_p(ts_dir)
    modulemap = File.join(ts_dir, "GoogleUtilities-#{subspec}.modulemap")
    File.write(modulemap, <<~MAP)
module GoogleUtilities_#{sanitized} {
  header "#{header_path}"
  export *
}
MAP

    installer.pods_project.targets.each do |target|
      next unless target.name == "GoogleUtilities-#{subspec}" || target.name == "GoogleUtilities_#{subspec}" || target.name == "GoogleUtilities_#{sanitized}"
      target.build_configurations.each do |config|
        config.build_settings['MODULEMAP_FILE'] = modulemap
        config.build_settings['DEFINES_MODULE'] = 'YES'
        config.build_settings['CLANG_ENABLE_MODULES'] = 'YES'
      end
    end

  end

  # Build a canonical modulemap + umbrella header for all GoogleUtilities subspecs so Swift imports
  # never depend on CocoaPods' generated files (which can be skipped when we override modulemaps).
  gu_ts_dir = File.join(installer.sandbox.root, 'Target Support Files', 'GoogleUtilities')
  gu_modulemap = File.join(gu_ts_dir, 'GoogleUtilities.modulemap')
  FileUtils.mkdir_p(gu_ts_dir)

  header_paths = {}
  gu_subspecs.each do |subspec, header_names|
    header_path = resolve_header.call(header_names)
    header_paths[subspec] = header_path if header_path && File.exist?(header_path)
  end

  gu_umbrella_path = File.join(gu_ts_dir, 'GoogleUtilities-umbrella.h')
  File.open(gu_umbrella_path, 'w') do |f|
    f.puts '#ifdef __OBJC__'
    header_paths.values.compact.uniq.each { |hdr| f.puts "#import \"#{hdr}\"" }
    f.puts '#endif'
  end

  modulemap_contents = <<~MAP
module GoogleUtilities {
  umbrella header "#{gu_umbrella_path}"
  export *
  module * { export * }
}
MAP

  header_paths.each do |subspec, hdr|
    # Module names must be valid identifiers; sanitize subspec names like "NSData+zlib".
    mod_name = subspec.gsub(/[^A-Za-z0-9_]/, '_')
    modulemap_contents << "\nmodule GoogleUtilities_#{mod_name} {\n  header \"#{hdr}\"\n  export *\n}\n"
  end

  File.write(gu_modulemap, modulemap_contents)

  installer.pods_project.targets.each do |target|
    next unless target.name.include?('GoogleUtilities')
    target.build_configurations.each do |config|
      config.build_settings['MODULEMAP_FILE'] = gu_modulemap
      config.build_settings['DEFINES_MODULE'] = 'YES'
      config.build_settings['CLANG_ENABLE_MODULES'] = 'YES'
      flags = Array(config.build_settings['OTHER_SWIFT_FLAGS']).dup
      flag = "-fmodule-map-file=#{Shellwords.escape(gu_modulemap)}"
      flags += ['-Xcc', flag] unless flags.include?(flag) || (flags.include?('-Xcc') && flags.include?(flag))
      config.build_settings['OTHER_SWIFT_FLAGS'] = flags
    end
  end

  # Propagate the consolidated modulemap to downstream Swift consumers (e.g., FirebaseAuth) so
  # imports like GoogleUtilities_Environment resolve even when the GoogleUtilities targets are
  # built as static frameworks.
  installer.pods_project.targets.each do |target|
    next unless target.name.start_with?('Pods-') || target.name.start_with?('Firebase') || target.name.start_with?('GoogleUtilities')

    target.build_configurations.each do |config|
      flags = Array(config.build_settings['OTHER_SWIFT_FLAGS']).dup
      flag = "-fmodule-map-file=#{Shellwords.escape(gu_modulemap)}"
      # Add as an Xcc flag to ensure the Swift frontend forwards it to Clang.
      unless flags.include?(flag) || (flags.include?('-Xcc') && flags.include?(flag))
        flags += ['-Xcc', flag]
      end
      config.build_settings['OTHER_SWIFT_FLAGS'] = flags
    end
  end

  # Provide a real alias modulemap so Swift imports of GTMSessionFetcherCore see the same headers as GTMSessionFetcher.
  gtm_header_any = Dir.glob(File.join(installer.sandbox.root, 'GTMSessionFetcher', '**', 'GTMSessionFetcher.h')).first
  if gtm_header_any && File.exist?(gtm_header_any)
    ts_dir = File.join(installer.sandbox.root, 'Target Support Files', 'GTMSessionFetcher')
    FileUtils.mkdir_p(ts_dir)

    # Prefer the generated umbrella header so the module exposes the full surface area.
    gtm_umbrella = Dir.glob(File.join(ts_dir, 'GTMSessionFetcher-umbrella.h')).first
    gtm_header = gtm_umbrella || gtm_header_any

    gtm_core_alias = File.join(ts_dir, 'GTMSessionFetcherCore.alias.modulemap')
    File.write(gtm_core_alias, <<~MAP)
module GTMSessionFetcherCore {
  header "#{gtm_header}"
  export *
  export_as GTMSessionFetcher
}
MAP

    installer.pods_project.targets.each do |target|
      needs_flag = target.name.include?('GTMSessionFetcher') || target.name.start_with?('Pods-') || target.name.start_with?('Firebase')
      next unless needs_flag
      target.build_configurations.each do |config|
        flags = Array(config.build_settings['OTHER_SWIFT_FLAGS']).dup
        flag = "-fmodule-map-file=#{Shellwords.escape(gtm_core_alias)}"
        unless flags.include?(flag) || (flags.include?('-Xcc') && flags.include?(flag))
          flags += ['-Xcc', flag]
        end
        config.build_settings['OTHER_SWIFT_FLAGS'] = flags
      end
    end
  end

  # (legacy alias block removed)

  # GTMSessionFetcher: use upstream modulemaps without overrides.

  installer.pods_project.targets.each do |target|
    next unless target.name.include?('GoogleUtilities')
    target.build_configurations.each do |config|
      config.build_settings['DEFINES_MODULE'] = 'YES'
      config.build_settings['CLANG_ENABLE_MODULES'] = 'YES'
    end
  end

  # Ensure a dedicated modulemap exists for GoogleUtilities_AppDelegateSwizzler and avoid module cycles.
  swizzler_header = Dir.glob(File.join(installer.sandbox.root, 'GoogleUtilities', '**', 'GULAppDelegateSwizzler.h')).first
  # Grab SceneDelegateSwizzler header if present so the module exposes both symbols to Swift.
  scene_swizzler_header_for_app_delegate = Dir.glob(File.join(installer.sandbox.root, 'GoogleUtilities', '**', 'GULSceneDelegateSwizzler.h')).first
  if swizzler_header && File.exist?(swizzler_header)
    ts_dir = File.join(installer.sandbox.root, 'Target Support Files', 'GoogleUtilities-AppDelegateSwizzler')
    FileUtils.mkdir_p(ts_dir)
    swizzler_modulemap = File.join(ts_dir, 'GoogleUtilities-AppDelegateSwizzler.modulemap')
    modulemap_body = <<~MAP
module GoogleUtilities_AppDelegateSwizzler {
  header "#{swizzler_header}"
  #{scene_swizzler_header_for_app_delegate && File.exist?(scene_swizzler_header_for_app_delegate) ? "header \"#{scene_swizzler_header_for_app_delegate}\"" : ''}
  export *
}
MAP
    File.write(swizzler_modulemap, modulemap_body)

    installer.pods_project.targets.each do |target|
      next unless target.name == "GoogleUtilities-AppDelegateSwizzler" || target.name == "GoogleUtilities-SceneDelegateSwizzler"
      target.build_configurations.each do |config|
        config.build_settings['MODULEMAP_FILE'] = swizzler_modulemap
        config.build_settings['DEFINES_MODULE'] = 'YES'
        config.build_settings['CLANG_ENABLE_MODULES'] = 'YES'
      end
    end

  end

  # Ensure a dedicated modulemap exists for GoogleUtilities_SceneDelegateSwizzler. If the header is missing (older GoogleUtilities), synthesize a shim.
  scene_swizzler_header = resolve_header.call(['GULSceneDelegateSwizzler.h'])
  unless scene_swizzler_header && File.exist?(scene_swizzler_header)
    ts_dir = File.join(installer.sandbox.root, 'Target Support Files', 'GoogleUtilities-SceneDelegateSwizzler')
    FileUtils.mkdir_p(ts_dir)
    scene_swizzler_header = File.join(ts_dir, 'GULSceneDelegateSwizzler.h')
    File.write(scene_swizzler_header, <<~HDR)
#import <Foundation/Foundation.h>
// Shim header to satisfy FirebaseAuth when GoogleUtilities omits GULSceneDelegateSwizzler.
@interface GULSceneDelegateSwizzler : NSObject
@end
HDR
  end

  if scene_swizzler_header && File.exist?(scene_swizzler_header)
    ts_dir = File.join(installer.sandbox.root, 'Target Support Files', 'GoogleUtilities-SceneDelegateSwizzler')
    FileUtils.mkdir_p(ts_dir)
    scene_swizzler_modulemap = File.join(ts_dir, 'GoogleUtilities-SceneDelegateSwizzler.modulemap')
    File.write(scene_swizzler_modulemap, <<~MAP)
module GoogleUtilities_SceneDelegateSwizzler {
  header "#{scene_swizzler_header}"
  export *
}
MAP

    installer.pods_project.targets.each do |target|
      next unless target.name == 'GoogleUtilities-SceneDelegateSwizzler'
      target.build_configurations.each do |config|
        config.build_settings['MODULEMAP_FILE'] = scene_swizzler_modulemap
        config.build_settings['DEFINES_MODULE'] = 'YES'
        config.build_settings['CLANG_ENABLE_MODULES'] = 'YES'
      end
    end

    # Ensure the consolidated GoogleUtilities modulemap/umbrella now includes the SceneDelegateSwizzler header (shim or real).
    header_paths['SceneDelegateSwizzler'] = scene_swizzler_header
    gu_umbrella_path = File.join(gu_ts_dir, 'GoogleUtilities-umbrella.h')
    File.open(gu_umbrella_path, 'w') do |f|
      f.puts '#ifdef __OBJC__'
      header_paths.values.compact.uniq.each { |hdr| f.puts "#import \"#{hdr}\"" }
      f.puts '#endif'
    end

    modulemap_contents = <<~MAP
module GoogleUtilities {
  umbrella header "#{gu_umbrella_path}"
  export *
  module * { export * }
}
MAP

    header_paths.each do |subspec, hdr|
      mod_name = subspec.gsub(/[^A-Za-z0-9_]/, '_')
      modulemap_contents << "\nmodule GoogleUtilities_#{mod_name} {\n  header \"#{hdr}\"\n  export *\n}\n"
    end

    File.write(gu_modulemap, modulemap_contents)

    installer.pods_project.targets.each do |target|
      next unless target.name.include?('GoogleUtilities') || target.name.start_with?('Pods-') || target.name.start_with?('Firebase')
      target.build_configurations.each do |config|
        flags = Array(config.build_settings['OTHER_SWIFT_FLAGS']).dup
        flag = "-fmodule-map-file=#{Shellwords.escape(gu_modulemap)}"
        flags += ['-Xcc', flag] unless flags.include?(flag) || (flags.include?('-Xcc') && flags.include?(flag))
        config.build_settings['OTHER_SWIFT_FLAGS'] = flags
        if target.name.include?('GoogleUtilities')
          config.build_settings['MODULEMAP_FILE'] = gu_modulemap
          config.build_settings['DEFINES_MODULE'] = 'YES'
          config.build_settings['CLANG_ENABLE_MODULES'] = 'YES'
        end
      end
    end
  end

  # (SceneDelegateSwizzler shim removed to avoid duplicate module definitions)

  # If the SceneDelegateSwizzler header (real or shim) exists, also expose it through the
  # AppDelegateSwizzler modulemap so FirebaseAuth's Swift source can see the symbol.
  app_delegate_modulemap = File.join(installer.sandbox.root, 'Target Support Files', 'GoogleUtilities-AppDelegateSwizzler', 'GoogleUtilities-AppDelegateSwizzler.modulemap')
  if swizzler_header && File.exist?(swizzler_header) && scene_swizzler_header && File.exist?(scene_swizzler_header) && File.exist?(app_delegate_modulemap)
    File.write(app_delegate_modulemap, <<~MAP)
module GoogleUtilities_AppDelegateSwizzler {
  header "#{swizzler_header}"
  header "#{scene_swizzler_header}"
  export *
}
MAP
  end

  # (SceneDelegateSwizzler and GTMSessionFetcherCore modulemap shims removed)

  # Inject a Swift-side shim for GULSceneDelegateSwizzler if the module is not available at compile time.
  auth_swift = Dir.glob(File.join(installer.sandbox.root, 'FirebaseAuth', '**', 'Auth.swift')).first
  if auth_swift && File.exist?(auth_swift)
    auth_contents = File.read(auth_swift)
    marker = '// [Podfile] GULSceneDelegateSwizzler shim'
    unless auth_contents.include?(marker)
      shim = <<~SWIFT
#{marker}
#if canImport(GoogleUtilities_SceneDelegateSwizzler)
import GoogleUtilities_SceneDelegateSwizzler
#else
class GULSceneDelegateSwizzler {
  static func swizzleIfPossible() {}
}
#endif
SWIFT
      auth_contents = auth_contents.sub("import Foundation\n", "import Foundation\n#{shim}\n")
      File.write(auth_swift, auth_contents)
    end
  end

  # Patch Firebase pods to strip Swift 6-only syntax that Xcode 15.4 cannot compile.
  patches = [
    { file: 'FirebaseDataEncoder.swift', from: '-> sending Any', to: '-> Any' },
    { file: 'UnfairLock.swift', from: /\bsending\s+/, to: '' },
    { file: 'HeartbeatsPayload.swift', from: /^(internal|package)\s+import/, to: 'import' },
    { file: 'UnfairLock.swift', from: /^(private|package)\s+import/, to: 'import' },
    { file: 'AuthAPNSTokenManager.swift', from: /\bsending\s+/, to: '' }
  ]

  patches.each do |patch|
    Dir.glob(File.join(installer.sandbox.root, '**', patch[:file])).each do |path|
      contents = File.read(path)
      fixed = contents.gsub(patch[:from], patch[:to])
      File.write(path, fixed) if fixed != contents
    end
  end
end
